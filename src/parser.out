Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    AND
    CLASS
    COMMA
    CONSOLE
    DIVIDE
    DOT
    ELSE
    EQ
    FOR
    GE
    GET
    GT
    IF
    LBRACE
    LE
    LPAREN
    LT
    MINUS
    MOD
    NE
    NOT
    OR
    PLUS
    PUBLIC
    RBRACE
    READLINE
    RETURN
    RPAREN
    SET
    TIMES
    USING
    VOID
    WRITELINE

Grammar

Rule 0     S' -> start
Rule 1     start -> var_decls
Rule 2     var_decls -> var_decls var_decl
Rule 3     var_decls -> var_decl
Rule 4     type -> INT
Rule 5     type -> DOUBLE
Rule 6     type -> FLOAT
Rule 7     type -> BOOL
Rule 8     type -> STRINGTYPE
Rule 9     type -> CHAR
Rule 10    type -> VAR
Rule 11    type -> LIST
Rule 12    expr -> INT
Rule 13    expr -> FLOAT
Rule 14    expr -> DOUBLE
Rule 15    expr -> STRING
Rule 16    expr -> CHAR
Rule 17    expr -> TRUE
Rule 18    expr -> FALSE
Rule 19    expr -> ID
Rule 20    var_decl -> type ID EQUALS expr SEMICOLON
Rule 21    var_decl -> type ID SEMICOLON

Terminals, with rules where they appear

AND                  : 
BOOL                 : 7
CHAR                 : 9 16
CLASS                : 
COMMA                : 
CONSOLE              : 
DIVIDE               : 
DOT                  : 
DOUBLE               : 5 14
ELSE                 : 
EQ                   : 
EQUALS               : 20
FALSE                : 18
FLOAT                : 6 13
FOR                  : 
GE                   : 
GET                  : 
GT                   : 
ID                   : 19 20 21
IF                   : 
INT                  : 4 12
LBRACE               : 
LE                   : 
LIST                 : 11
LPAREN               : 
LT                   : 
MINUS                : 
MOD                  : 
NE                   : 
NOT                  : 
OR                   : 
PLUS                 : 
PUBLIC               : 
RBRACE               : 
READLINE             : 
RETURN               : 
RPAREN               : 
SEMICOLON            : 20 21
SET                  : 
STRING               : 15
STRINGTYPE           : 8
TIMES                : 
TRUE                 : 17
USING                : 
VAR                  : 10
VOID                 : 
WRITELINE            : 
error                : 

Nonterminals, with rules where they appear

expr                 : 20
start                : 0
type                 : 20 21
var_decl             : 2 3
var_decls            : 1 2

Parsing method: LALR

state 0

    (0) S' -> . start
    (1) start -> . var_decls
    (2) var_decls -> . var_decls var_decl
    (3) var_decls -> . var_decl
    (20) var_decl -> . type ID EQUALS expr SEMICOLON
    (21) var_decl -> . type ID SEMICOLON
    (4) type -> . INT
    (5) type -> . DOUBLE
    (6) type -> . FLOAT
    (7) type -> . BOOL
    (8) type -> . STRINGTYPE
    (9) type -> . CHAR
    (10) type -> . VAR
    (11) type -> . LIST

    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    FLOAT           shift and go to state 7
    BOOL            shift and go to state 8
    STRINGTYPE      shift and go to state 9
    CHAR            shift and go to state 10
    VAR             shift and go to state 11
    LIST            shift and go to state 12

    start                          shift and go to state 1
    var_decls                      shift and go to state 2
    var_decl                       shift and go to state 3
    type                           shift and go to state 4

state 1

    (0) S' -> start .



state 2

    (1) start -> var_decls .
    (2) var_decls -> var_decls . var_decl
    (20) var_decl -> . type ID EQUALS expr SEMICOLON
    (21) var_decl -> . type ID SEMICOLON
    (4) type -> . INT
    (5) type -> . DOUBLE
    (6) type -> . FLOAT
    (7) type -> . BOOL
    (8) type -> . STRINGTYPE
    (9) type -> . CHAR
    (10) type -> . VAR
    (11) type -> . LIST

    $end            reduce using rule 1 (start -> var_decls .)
    INT             shift and go to state 5
    DOUBLE          shift and go to state 6
    FLOAT           shift and go to state 7
    BOOL            shift and go to state 8
    STRINGTYPE      shift and go to state 9
    CHAR            shift and go to state 10
    VAR             shift and go to state 11
    LIST            shift and go to state 12

    var_decl                       shift and go to state 13
    type                           shift and go to state 4

state 3

    (3) var_decls -> var_decl .

    INT             reduce using rule 3 (var_decls -> var_decl .)
    DOUBLE          reduce using rule 3 (var_decls -> var_decl .)
    FLOAT           reduce using rule 3 (var_decls -> var_decl .)
    BOOL            reduce using rule 3 (var_decls -> var_decl .)
    STRINGTYPE      reduce using rule 3 (var_decls -> var_decl .)
    CHAR            reduce using rule 3 (var_decls -> var_decl .)
    VAR             reduce using rule 3 (var_decls -> var_decl .)
    LIST            reduce using rule 3 (var_decls -> var_decl .)
    $end            reduce using rule 3 (var_decls -> var_decl .)


state 4

    (20) var_decl -> type . ID EQUALS expr SEMICOLON
    (21) var_decl -> type . ID SEMICOLON

    ID              shift and go to state 14


state 5

    (4) type -> INT .

    ID              reduce using rule 4 (type -> INT .)


state 6

    (5) type -> DOUBLE .

    ID              reduce using rule 5 (type -> DOUBLE .)


state 7

    (6) type -> FLOAT .

    ID              reduce using rule 6 (type -> FLOAT .)


state 8

    (7) type -> BOOL .

    ID              reduce using rule 7 (type -> BOOL .)


state 9

    (8) type -> STRINGTYPE .

    ID              reduce using rule 8 (type -> STRINGTYPE .)


state 10

    (9) type -> CHAR .

    ID              reduce using rule 9 (type -> CHAR .)


state 11

    (10) type -> VAR .

    ID              reduce using rule 10 (type -> VAR .)


state 12

    (11) type -> LIST .

    ID              reduce using rule 11 (type -> LIST .)


state 13

    (2) var_decls -> var_decls var_decl .

    INT             reduce using rule 2 (var_decls -> var_decls var_decl .)
    DOUBLE          reduce using rule 2 (var_decls -> var_decls var_decl .)
    FLOAT           reduce using rule 2 (var_decls -> var_decls var_decl .)
    BOOL            reduce using rule 2 (var_decls -> var_decls var_decl .)
    STRINGTYPE      reduce using rule 2 (var_decls -> var_decls var_decl .)
    CHAR            reduce using rule 2 (var_decls -> var_decls var_decl .)
    VAR             reduce using rule 2 (var_decls -> var_decls var_decl .)
    LIST            reduce using rule 2 (var_decls -> var_decls var_decl .)
    $end            reduce using rule 2 (var_decls -> var_decls var_decl .)


state 14

    (20) var_decl -> type ID . EQUALS expr SEMICOLON
    (21) var_decl -> type ID . SEMICOLON

    EQUALS          shift and go to state 15
    SEMICOLON       shift and go to state 16


state 15

    (20) var_decl -> type ID EQUALS . expr SEMICOLON
    (12) expr -> . INT
    (13) expr -> . FLOAT
    (14) expr -> . DOUBLE
    (15) expr -> . STRING
    (16) expr -> . CHAR
    (17) expr -> . TRUE
    (18) expr -> . FALSE
    (19) expr -> . ID

    INT             shift and go to state 19
    FLOAT           shift and go to state 20
    DOUBLE          shift and go to state 21
    STRING          shift and go to state 22
    CHAR            shift and go to state 23
    TRUE            shift and go to state 24
    FALSE           shift and go to state 25
    ID              shift and go to state 17

    expr                           shift and go to state 18

state 16

    (21) var_decl -> type ID SEMICOLON .

    INT             reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    DOUBLE          reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    FLOAT           reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    BOOL            reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    STRINGTYPE      reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    CHAR            reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    VAR             reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    LIST            reduce using rule 21 (var_decl -> type ID SEMICOLON .)
    $end            reduce using rule 21 (var_decl -> type ID SEMICOLON .)


state 17

    (19) expr -> ID .

    SEMICOLON       reduce using rule 19 (expr -> ID .)


state 18

    (20) var_decl -> type ID EQUALS expr . SEMICOLON

    SEMICOLON       shift and go to state 26


state 19

    (12) expr -> INT .

    SEMICOLON       reduce using rule 12 (expr -> INT .)


state 20

    (13) expr -> FLOAT .

    SEMICOLON       reduce using rule 13 (expr -> FLOAT .)


state 21

    (14) expr -> DOUBLE .

    SEMICOLON       reduce using rule 14 (expr -> DOUBLE .)


state 22

    (15) expr -> STRING .

    SEMICOLON       reduce using rule 15 (expr -> STRING .)


state 23

    (16) expr -> CHAR .

    SEMICOLON       reduce using rule 16 (expr -> CHAR .)


state 24

    (17) expr -> TRUE .

    SEMICOLON       reduce using rule 17 (expr -> TRUE .)


state 25

    (18) expr -> FALSE .

    SEMICOLON       reduce using rule 18 (expr -> FALSE .)


state 26

    (20) var_decl -> type ID EQUALS expr SEMICOLON .

    INT             reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    VAR             reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    LIST            reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)
    $end            reduce using rule 20 (var_decl -> type ID EQUALS expr SEMICOLON .)

