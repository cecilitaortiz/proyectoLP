Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ABSTRACT
    ADD
    AMPERSAND
    APOSTROPHE
    ARROW
    BASE
    BREAK
    CASE
    CATCH
    COLON
    COMMENT
    CONST
    CONTINUE
    DECREMENT
    DIVEQ
    DO
    DOT
    ENUM
    EVENT
    FINALLY
    FOREACH
    GET
    INCREMENT
    INTERFACE
    LBRACKET
    MINUSEQ
    MODEQ
    NEW
    NULL
    OBJECT
    OPERATOR
    OUT
    OVERRIDE
    PARAMS
    PIPE
    PLUSEQ
    PRIVATE
    PROTECTED
    QUESTION
    QUOTE
    RBRACKET
    READONLY
    REF
    REMOVE
    SET
    STATIC
    SWITCH
    THIS
    THROW
    TIMESEQ
    TRY
    VIRTUAL
    WHILE

Grammar

Rule 0     S' -> program
Rule 1     program -> using_list class_list
Rule 2     using_list -> using_list using_stmt
Rule 3     using_list -> empty
Rule 4     using_stmt -> USING ID SEMICOLON
Rule 5     class_list -> class_list class_decl
Rule 6     class_list -> class_decl
Rule 7     class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE
Rule 8     member_list -> member_list member
Rule 9     member_list -> empty
Rule 10    member -> method_decl
Rule 11    member -> var_decl
Rule 12    method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
Rule 13    var_decl -> type ID EQUALS expr SEMICOLON
Rule 14    var_decl -> type ID SEMICOLON
Rule 15    param_list -> param_list COMMA param
Rule 16    param_list -> param
Rule 17    param_list -> empty
Rule 18    param -> type ID
Rule 19    type -> INT
Rule 20    type -> FLOAT
Rule 21    type -> DOUBLE
Rule 22    type -> STRINGTYPE
Rule 23    type -> BOOL
Rule 24    type -> CHAR
Rule 25    type -> VOID
Rule 26    type -> VAR
Rule 27    type -> LIST LT type GT
Rule 28    stmt_list -> stmt_list stmt
Rule 29    stmt_list -> empty
Rule 30    stmt -> var_decl
Rule 31    stmt -> assign_stmt
Rule 32    stmt -> if_stmt
Rule 33    stmt -> return_stmt
Rule 34    stmt -> for_stmt
Rule 35    assign_stmt -> ID EQUALS expr SEMICOLON
Rule 36    if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
Rule 37    else_part -> ELSE LBRACE stmt_list RBRACE
Rule 38    else_part -> empty
Rule 39    return_stmt -> RETURN expr SEMICOLON
Rule 40    for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
Rule 41    expr -> LPAREN type RPAREN expr
Rule 42    expr -> expr PLUS expr
Rule 43    expr -> expr MINUS expr
Rule 44    expr -> expr TIMES expr
Rule 45    expr -> expr DIVIDE expr
Rule 46    expr -> expr MOD expr
Rule 47    expr -> expr EQ expr
Rule 48    expr -> expr NE expr
Rule 49    expr -> expr LT expr
Rule 50    expr -> expr LE expr
Rule 51    expr -> expr GT expr
Rule 52    expr -> expr GE expr
Rule 53    expr -> expr AND expr
Rule 54    expr -> expr OR expr
Rule 55    expr -> LPAREN expr RPAREN
Rule 56    expr -> NOT expr
Rule 57    expr -> MINUS expr
Rule 58    expr -> ID
Rule 59    expr -> INT
Rule 60    expr -> FLOAT
Rule 61    expr -> DOUBLE
Rule 62    expr -> STRING
Rule 63    expr -> TRUE
Rule 64    expr -> FALSE
Rule 65    expr -> CHAR
Rule 66    empty -> <empty>

Terminals, with rules where they appear

ABSTRACT             : 
ADD                  : 
AMPERSAND            : 
AND                  : 53
APOSTROPHE           : 
ARROW                : 
BASE                 : 
BOOL                 : 23
BREAK                : 
CASE                 : 
CATCH                : 
CHAR                 : 24 65
CLASS                : 7
COLON                : 
COMMA                : 15
COMMENT              : 
CONST                : 
CONTINUE             : 
DECREMENT            : 
DIVEQ                : 
DIVIDE               : 45
DO                   : 
DOT                  : 
DOUBLE               : 21 61
ELSE                 : 37
ENUM                 : 
EQ                   : 47
EQUALS               : 13 35
EVENT                : 
FALSE                : 64
FINALLY              : 
FLOAT                : 20 60
FOR                  : 40
FOREACH              : 
GE                   : 52
GET                  : 
GT                   : 27 51
ID                   : 4 7 12 13 14 18 35 58
IF                   : 36
INCREMENT            : 
INT                  : 19 59
INTERFACE            : 
LBRACE               : 7 12 36 37 40
LBRACKET             : 
LE                   : 50
LIST                 : 27
LPAREN               : 12 36 40 41 55
LT                   : 27 49
MINUS                : 43 57
MINUSEQ              : 
MOD                  : 46
MODEQ                : 
NE                   : 48
NEW                  : 
NOT                  : 56
NULL                 : 
OBJECT               : 
OPERATOR             : 
OR                   : 54
OUT                  : 
OVERRIDE             : 
PARAMS               : 
PIPE                 : 
PLUS                 : 42
PLUSEQ               : 
PRIVATE              : 
PROTECTED            : 
PUBLIC               : 7 12
QUESTION             : 
QUOTE                : 
RBRACE               : 7 12 36 37 40
RBRACKET             : 
READONLY             : 
REF                  : 
REMOVE               : 
RETURN               : 39
RPAREN               : 12 36 40 41 55
SEMICOLON            : 4 13 14 35 39 40
SET                  : 
STATIC               : 
STRING               : 62
STRINGTYPE           : 22
SWITCH               : 
THIS                 : 
THROW                : 
TIMES                : 44
TIMESEQ              : 
TRUE                 : 63
TRY                  : 
USING                : 4
VAR                  : 26
VIRTUAL              : 
VOID                 : 25
WHILE                : 
error                : 

Nonterminals, with rules where they appear

assign_stmt          : 31 40 40
class_decl           : 5 6
class_list           : 1 5
else_part            : 36
empty                : 3 9 17 29 38
expr                 : 13 35 36 39 40 41 42 42 43 43 44 44 45 45 46 46 47 47 48 48 49 49 50 50 51 51 52 52 53 53 54 54 55 56 57
for_stmt             : 34
if_stmt              : 32
member               : 8
member_list          : 7 8
method_decl          : 10
param                : 15 16
param_list           : 12 15
program              : 0
return_stmt          : 33
stmt                 : 28
stmt_list            : 12 28 36 37 40
type                 : 12 13 14 18 27 41
using_list           : 1 2
using_stmt           : 2
var_decl             : 11 30

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . using_list class_list
    (2) using_list -> . using_list using_stmt
    (3) using_list -> . empty
    (66) empty -> .

    USING           reduce using rule 66 (empty -> .)
    PUBLIC          reduce using rule 66 (empty -> .)

    program                        shift and go to state 1
    using_list                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> using_list . class_list
    (2) using_list -> using_list . using_stmt
    (5) class_list -> . class_list class_decl
    (6) class_list -> . class_decl
    (4) using_stmt -> . USING ID SEMICOLON
    (7) class_decl -> . PUBLIC CLASS ID LBRACE member_list RBRACE

    USING           shift and go to state 7
    PUBLIC          shift and go to state 8

    class_list                     shift and go to state 4
    using_stmt                     shift and go to state 5
    class_decl                     shift and go to state 6

state 3

    (3) using_list -> empty .

    USING           reduce using rule 3 (using_list -> empty .)
    PUBLIC          reduce using rule 3 (using_list -> empty .)


state 4

    (1) program -> using_list class_list .
    (5) class_list -> class_list . class_decl
    (7) class_decl -> . PUBLIC CLASS ID LBRACE member_list RBRACE

    $end            reduce using rule 1 (program -> using_list class_list .)
    PUBLIC          shift and go to state 8

    class_decl                     shift and go to state 9

state 5

    (2) using_list -> using_list using_stmt .

    USING           reduce using rule 2 (using_list -> using_list using_stmt .)
    PUBLIC          reduce using rule 2 (using_list -> using_list using_stmt .)


state 6

    (6) class_list -> class_decl .

    PUBLIC          reduce using rule 6 (class_list -> class_decl .)
    $end            reduce using rule 6 (class_list -> class_decl .)


state 7

    (4) using_stmt -> USING . ID SEMICOLON

    ID              shift and go to state 10


state 8

    (7) class_decl -> PUBLIC . CLASS ID LBRACE member_list RBRACE

    CLASS           shift and go to state 11


state 9

    (5) class_list -> class_list class_decl .

    PUBLIC          reduce using rule 5 (class_list -> class_list class_decl .)
    $end            reduce using rule 5 (class_list -> class_list class_decl .)


state 10

    (4) using_stmt -> USING ID . SEMICOLON

    SEMICOLON       shift and go to state 12


state 11

    (7) class_decl -> PUBLIC CLASS . ID LBRACE member_list RBRACE

    ID              shift and go to state 13


state 12

    (4) using_stmt -> USING ID SEMICOLON .

    USING           reduce using rule 4 (using_stmt -> USING ID SEMICOLON .)
    PUBLIC          reduce using rule 4 (using_stmt -> USING ID SEMICOLON .)


state 13

    (7) class_decl -> PUBLIC CLASS ID . LBRACE member_list RBRACE

    LBRACE          shift and go to state 14


state 14

    (7) class_decl -> PUBLIC CLASS ID LBRACE . member_list RBRACE
    (8) member_list -> . member_list member
    (9) member_list -> . empty
    (66) empty -> .

    RBRACE          reduce using rule 66 (empty -> .)
    PUBLIC          reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    member_list                    shift and go to state 15
    empty                          shift and go to state 16

state 15

    (7) class_decl -> PUBLIC CLASS ID LBRACE member_list . RBRACE
    (8) member_list -> member_list . member
    (10) member -> . method_decl
    (11) member -> . var_decl
    (12) method_decl -> . PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (13) var_decl -> . type ID EQUALS expr SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RBRACE          shift and go to state 18
    PUBLIC          shift and go to state 17
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    member                         shift and go to state 19
    method_decl                    shift and go to state 20
    var_decl                       shift and go to state 21
    type                           shift and go to state 22

state 16

    (9) member_list -> empty .

    RBRACE          reduce using rule 9 (member_list -> empty .)
    PUBLIC          reduce using rule 9 (member_list -> empty .)
    INT             reduce using rule 9 (member_list -> empty .)
    FLOAT           reduce using rule 9 (member_list -> empty .)
    DOUBLE          reduce using rule 9 (member_list -> empty .)
    STRINGTYPE      reduce using rule 9 (member_list -> empty .)
    BOOL            reduce using rule 9 (member_list -> empty .)
    CHAR            reduce using rule 9 (member_list -> empty .)
    VOID            reduce using rule 9 (member_list -> empty .)
    VAR             reduce using rule 9 (member_list -> empty .)
    LIST            reduce using rule 9 (member_list -> empty .)


state 17

    (12) method_decl -> PUBLIC . type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    type                           shift and go to state 32

state 18

    (7) class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .

    PUBLIC          reduce using rule 7 (class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .)
    $end            reduce using rule 7 (class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .)


state 19

    (8) member_list -> member_list member .

    RBRACE          reduce using rule 8 (member_list -> member_list member .)
    PUBLIC          reduce using rule 8 (member_list -> member_list member .)
    INT             reduce using rule 8 (member_list -> member_list member .)
    FLOAT           reduce using rule 8 (member_list -> member_list member .)
    DOUBLE          reduce using rule 8 (member_list -> member_list member .)
    STRINGTYPE      reduce using rule 8 (member_list -> member_list member .)
    BOOL            reduce using rule 8 (member_list -> member_list member .)
    CHAR            reduce using rule 8 (member_list -> member_list member .)
    VOID            reduce using rule 8 (member_list -> member_list member .)
    VAR             reduce using rule 8 (member_list -> member_list member .)
    LIST            reduce using rule 8 (member_list -> member_list member .)


state 20

    (10) member -> method_decl .

    RBRACE          reduce using rule 10 (member -> method_decl .)
    PUBLIC          reduce using rule 10 (member -> method_decl .)
    INT             reduce using rule 10 (member -> method_decl .)
    FLOAT           reduce using rule 10 (member -> method_decl .)
    DOUBLE          reduce using rule 10 (member -> method_decl .)
    STRINGTYPE      reduce using rule 10 (member -> method_decl .)
    BOOL            reduce using rule 10 (member -> method_decl .)
    CHAR            reduce using rule 10 (member -> method_decl .)
    VOID            reduce using rule 10 (member -> method_decl .)
    VAR             reduce using rule 10 (member -> method_decl .)
    LIST            reduce using rule 10 (member -> method_decl .)


state 21

    (11) member -> var_decl .

    RBRACE          reduce using rule 11 (member -> var_decl .)
    PUBLIC          reduce using rule 11 (member -> var_decl .)
    INT             reduce using rule 11 (member -> var_decl .)
    FLOAT           reduce using rule 11 (member -> var_decl .)
    DOUBLE          reduce using rule 11 (member -> var_decl .)
    STRINGTYPE      reduce using rule 11 (member -> var_decl .)
    BOOL            reduce using rule 11 (member -> var_decl .)
    CHAR            reduce using rule 11 (member -> var_decl .)
    VOID            reduce using rule 11 (member -> var_decl .)
    VAR             reduce using rule 11 (member -> var_decl .)
    LIST            reduce using rule 11 (member -> var_decl .)


state 22

    (13) var_decl -> type . ID EQUALS expr SEMICOLON
    (14) var_decl -> type . ID SEMICOLON

    ID              shift and go to state 33


state 23

    (19) type -> INT .

    ID              reduce using rule 19 (type -> INT .)
    GT              reduce using rule 19 (type -> INT .)


state 24

    (20) type -> FLOAT .

    ID              reduce using rule 20 (type -> FLOAT .)
    GT              reduce using rule 20 (type -> FLOAT .)


state 25

    (21) type -> DOUBLE .

    ID              reduce using rule 21 (type -> DOUBLE .)
    GT              reduce using rule 21 (type -> DOUBLE .)


state 26

    (22) type -> STRINGTYPE .

    ID              reduce using rule 22 (type -> STRINGTYPE .)
    GT              reduce using rule 22 (type -> STRINGTYPE .)
    RPAREN          reduce using rule 22 (type -> STRINGTYPE .)


state 27

    (23) type -> BOOL .

    ID              reduce using rule 23 (type -> BOOL .)
    GT              reduce using rule 23 (type -> BOOL .)
    RPAREN          reduce using rule 23 (type -> BOOL .)


state 28

    (24) type -> CHAR .

    ID              reduce using rule 24 (type -> CHAR .)
    GT              reduce using rule 24 (type -> CHAR .)


state 29

    (25) type -> VOID .

    ID              reduce using rule 25 (type -> VOID .)
    GT              reduce using rule 25 (type -> VOID .)
    RPAREN          reduce using rule 25 (type -> VOID .)


state 30

    (26) type -> VAR .

    ID              reduce using rule 26 (type -> VAR .)
    GT              reduce using rule 26 (type -> VAR .)
    RPAREN          reduce using rule 26 (type -> VAR .)


state 31

    (27) type -> LIST . LT type GT

    LT              shift and go to state 34


state 32

    (12) method_decl -> PUBLIC type . ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    ID              shift and go to state 35


state 33

    (13) var_decl -> type ID . EQUALS expr SEMICOLON
    (14) var_decl -> type ID . SEMICOLON

    EQUALS          shift and go to state 36
    SEMICOLON       shift and go to state 37


state 34

    (27) type -> LIST LT . type GT
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    type                           shift and go to state 38

state 35

    (12) method_decl -> PUBLIC type ID . LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 39


state 36

    (13) var_decl -> type ID EQUALS . expr SEMICOLON
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 41

state 37

    (14) var_decl -> type ID SEMICOLON .

    RBRACE          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    PUBLIC          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    FLOAT           reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    DOUBLE          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    STRINGTYPE      reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    BOOL            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    CHAR            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    VOID            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    VAR             reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    LIST            reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    RETURN          reduce using rule 14 (var_decl -> type ID SEMICOLON .)
    FOR             reduce using rule 14 (var_decl -> type ID SEMICOLON .)


state 38

    (27) type -> LIST LT type . GT

    GT              shift and go to state 52


state 39

    (12) method_decl -> PUBLIC type ID LPAREN . param_list RPAREN LBRACE stmt_list RBRACE
    (15) param_list -> . param_list COMMA param
    (16) param_list -> . param
    (17) param_list -> . empty
    (18) param -> . type ID
    (66) empty -> .
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RPAREN          reduce using rule 66 (empty -> .)
    COMMA           reduce using rule 66 (empty -> .)
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    type                           shift and go to state 53
    param_list                     shift and go to state 54
    param                          shift and go to state 55
    empty                          shift and go to state 56

state 40

    (58) expr -> ID .

    SEMICOLON       reduce using rule 58 (expr -> ID .)
    PLUS            reduce using rule 58 (expr -> ID .)
    MINUS           reduce using rule 58 (expr -> ID .)
    TIMES           reduce using rule 58 (expr -> ID .)
    DIVIDE          reduce using rule 58 (expr -> ID .)
    MOD             reduce using rule 58 (expr -> ID .)
    EQ              reduce using rule 58 (expr -> ID .)
    NE              reduce using rule 58 (expr -> ID .)
    LT              reduce using rule 58 (expr -> ID .)
    LE              reduce using rule 58 (expr -> ID .)
    GT              reduce using rule 58 (expr -> ID .)
    GE              reduce using rule 58 (expr -> ID .)
    AND             reduce using rule 58 (expr -> ID .)
    OR              reduce using rule 58 (expr -> ID .)
    RPAREN          reduce using rule 58 (expr -> ID .)


state 41

    (13) var_decl -> type ID EQUALS expr . SEMICOLON
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       shift and go to state 57
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 42

    (41) expr -> LPAREN . type RPAREN expr
    (55) expr -> LPAREN . expr RPAREN
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    INT             shift and go to state 73
    FLOAT           shift and go to state 74
    DOUBLE          shift and go to state 75
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 76
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31
    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50

    type                           shift and go to state 71
    expr                           shift and go to state 72

state 43

    (57) expr -> MINUS . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 77

state 44

    (56) expr -> NOT . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 78

state 45

    (59) expr -> INT .

    SEMICOLON       reduce using rule 59 (expr -> INT .)
    PLUS            reduce using rule 59 (expr -> INT .)
    MINUS           reduce using rule 59 (expr -> INT .)
    TIMES           reduce using rule 59 (expr -> INT .)
    DIVIDE          reduce using rule 59 (expr -> INT .)
    MOD             reduce using rule 59 (expr -> INT .)
    EQ              reduce using rule 59 (expr -> INT .)
    NE              reduce using rule 59 (expr -> INT .)
    LT              reduce using rule 59 (expr -> INT .)
    LE              reduce using rule 59 (expr -> INT .)
    GT              reduce using rule 59 (expr -> INT .)
    GE              reduce using rule 59 (expr -> INT .)
    AND             reduce using rule 59 (expr -> INT .)
    OR              reduce using rule 59 (expr -> INT .)
    RPAREN          reduce using rule 59 (expr -> INT .)


state 46

    (60) expr -> FLOAT .

    SEMICOLON       reduce using rule 60 (expr -> FLOAT .)
    PLUS            reduce using rule 60 (expr -> FLOAT .)
    MINUS           reduce using rule 60 (expr -> FLOAT .)
    TIMES           reduce using rule 60 (expr -> FLOAT .)
    DIVIDE          reduce using rule 60 (expr -> FLOAT .)
    MOD             reduce using rule 60 (expr -> FLOAT .)
    EQ              reduce using rule 60 (expr -> FLOAT .)
    NE              reduce using rule 60 (expr -> FLOAT .)
    LT              reduce using rule 60 (expr -> FLOAT .)
    LE              reduce using rule 60 (expr -> FLOAT .)
    GT              reduce using rule 60 (expr -> FLOAT .)
    GE              reduce using rule 60 (expr -> FLOAT .)
    AND             reduce using rule 60 (expr -> FLOAT .)
    OR              reduce using rule 60 (expr -> FLOAT .)
    RPAREN          reduce using rule 60 (expr -> FLOAT .)


state 47

    (61) expr -> DOUBLE .

    SEMICOLON       reduce using rule 61 (expr -> DOUBLE .)
    PLUS            reduce using rule 61 (expr -> DOUBLE .)
    MINUS           reduce using rule 61 (expr -> DOUBLE .)
    TIMES           reduce using rule 61 (expr -> DOUBLE .)
    DIVIDE          reduce using rule 61 (expr -> DOUBLE .)
    MOD             reduce using rule 61 (expr -> DOUBLE .)
    EQ              reduce using rule 61 (expr -> DOUBLE .)
    NE              reduce using rule 61 (expr -> DOUBLE .)
    LT              reduce using rule 61 (expr -> DOUBLE .)
    LE              reduce using rule 61 (expr -> DOUBLE .)
    GT              reduce using rule 61 (expr -> DOUBLE .)
    GE              reduce using rule 61 (expr -> DOUBLE .)
    AND             reduce using rule 61 (expr -> DOUBLE .)
    OR              reduce using rule 61 (expr -> DOUBLE .)
    RPAREN          reduce using rule 61 (expr -> DOUBLE .)


state 48

    (62) expr -> STRING .

    SEMICOLON       reduce using rule 62 (expr -> STRING .)
    PLUS            reduce using rule 62 (expr -> STRING .)
    MINUS           reduce using rule 62 (expr -> STRING .)
    TIMES           reduce using rule 62 (expr -> STRING .)
    DIVIDE          reduce using rule 62 (expr -> STRING .)
    MOD             reduce using rule 62 (expr -> STRING .)
    EQ              reduce using rule 62 (expr -> STRING .)
    NE              reduce using rule 62 (expr -> STRING .)
    LT              reduce using rule 62 (expr -> STRING .)
    LE              reduce using rule 62 (expr -> STRING .)
    GT              reduce using rule 62 (expr -> STRING .)
    GE              reduce using rule 62 (expr -> STRING .)
    AND             reduce using rule 62 (expr -> STRING .)
    OR              reduce using rule 62 (expr -> STRING .)
    RPAREN          reduce using rule 62 (expr -> STRING .)


state 49

    (63) expr -> TRUE .

    SEMICOLON       reduce using rule 63 (expr -> TRUE .)
    PLUS            reduce using rule 63 (expr -> TRUE .)
    MINUS           reduce using rule 63 (expr -> TRUE .)
    TIMES           reduce using rule 63 (expr -> TRUE .)
    DIVIDE          reduce using rule 63 (expr -> TRUE .)
    MOD             reduce using rule 63 (expr -> TRUE .)
    EQ              reduce using rule 63 (expr -> TRUE .)
    NE              reduce using rule 63 (expr -> TRUE .)
    LT              reduce using rule 63 (expr -> TRUE .)
    LE              reduce using rule 63 (expr -> TRUE .)
    GT              reduce using rule 63 (expr -> TRUE .)
    GE              reduce using rule 63 (expr -> TRUE .)
    AND             reduce using rule 63 (expr -> TRUE .)
    OR              reduce using rule 63 (expr -> TRUE .)
    RPAREN          reduce using rule 63 (expr -> TRUE .)


state 50

    (64) expr -> FALSE .

    SEMICOLON       reduce using rule 64 (expr -> FALSE .)
    PLUS            reduce using rule 64 (expr -> FALSE .)
    MINUS           reduce using rule 64 (expr -> FALSE .)
    TIMES           reduce using rule 64 (expr -> FALSE .)
    DIVIDE          reduce using rule 64 (expr -> FALSE .)
    MOD             reduce using rule 64 (expr -> FALSE .)
    EQ              reduce using rule 64 (expr -> FALSE .)
    NE              reduce using rule 64 (expr -> FALSE .)
    LT              reduce using rule 64 (expr -> FALSE .)
    LE              reduce using rule 64 (expr -> FALSE .)
    GT              reduce using rule 64 (expr -> FALSE .)
    GE              reduce using rule 64 (expr -> FALSE .)
    AND             reduce using rule 64 (expr -> FALSE .)
    OR              reduce using rule 64 (expr -> FALSE .)
    RPAREN          reduce using rule 64 (expr -> FALSE .)


state 51

    (65) expr -> CHAR .

    SEMICOLON       reduce using rule 65 (expr -> CHAR .)
    PLUS            reduce using rule 65 (expr -> CHAR .)
    MINUS           reduce using rule 65 (expr -> CHAR .)
    TIMES           reduce using rule 65 (expr -> CHAR .)
    DIVIDE          reduce using rule 65 (expr -> CHAR .)
    MOD             reduce using rule 65 (expr -> CHAR .)
    EQ              reduce using rule 65 (expr -> CHAR .)
    NE              reduce using rule 65 (expr -> CHAR .)
    LT              reduce using rule 65 (expr -> CHAR .)
    LE              reduce using rule 65 (expr -> CHAR .)
    GT              reduce using rule 65 (expr -> CHAR .)
    GE              reduce using rule 65 (expr -> CHAR .)
    AND             reduce using rule 65 (expr -> CHAR .)
    OR              reduce using rule 65 (expr -> CHAR .)
    RPAREN          reduce using rule 65 (expr -> CHAR .)


state 52

    (27) type -> LIST LT type GT .

    ID              reduce using rule 27 (type -> LIST LT type GT .)
    GT              reduce using rule 27 (type -> LIST LT type GT .)
    RPAREN          reduce using rule 27 (type -> LIST LT type GT .)


state 53

    (18) param -> type . ID

    ID              shift and go to state 79


state 54

    (12) method_decl -> PUBLIC type ID LPAREN param_list . RPAREN LBRACE stmt_list RBRACE
    (15) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 80
    COMMA           shift and go to state 81


state 55

    (16) param_list -> param .

    RPAREN          reduce using rule 16 (param_list -> param .)
    COMMA           reduce using rule 16 (param_list -> param .)


state 56

    (17) param_list -> empty .

    RPAREN          reduce using rule 17 (param_list -> empty .)
    COMMA           reduce using rule 17 (param_list -> empty .)


state 57

    (13) var_decl -> type ID EQUALS expr SEMICOLON .

    RBRACE          reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    PUBLIC          reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    VAR             reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    LIST            reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 13 (var_decl -> type ID EQUALS expr SEMICOLON .)


state 58

    (42) expr -> expr PLUS . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 82

state 59

    (43) expr -> expr MINUS . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 83

state 60

    (44) expr -> expr TIMES . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 84

state 61

    (45) expr -> expr DIVIDE . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 85

state 62

    (46) expr -> expr MOD . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 86

state 63

    (47) expr -> expr EQ . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 87

state 64

    (48) expr -> expr NE . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 88

state 65

    (49) expr -> expr LT . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 89

state 66

    (50) expr -> expr LE . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 90

state 67

    (51) expr -> expr GT . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 91

state 68

    (52) expr -> expr GE . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 92

state 69

    (53) expr -> expr AND . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 93

state 70

    (54) expr -> expr OR . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 94

state 71

    (41) expr -> LPAREN type . RPAREN expr

    RPAREN          shift and go to state 95


state 72

    (55) expr -> LPAREN expr . RPAREN
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    RPAREN          shift and go to state 96
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 73

    (19) type -> INT .
    (59) expr -> INT .

  ! reduce/reduce conflict for RPAREN resolved using rule 19 (type -> INT .)
    RPAREN          reduce using rule 19 (type -> INT .)
    PLUS            reduce using rule 59 (expr -> INT .)
    MINUS           reduce using rule 59 (expr -> INT .)
    TIMES           reduce using rule 59 (expr -> INT .)
    DIVIDE          reduce using rule 59 (expr -> INT .)
    MOD             reduce using rule 59 (expr -> INT .)
    EQ              reduce using rule 59 (expr -> INT .)
    NE              reduce using rule 59 (expr -> INT .)
    LT              reduce using rule 59 (expr -> INT .)
    LE              reduce using rule 59 (expr -> INT .)
    GT              reduce using rule 59 (expr -> INT .)
    GE              reduce using rule 59 (expr -> INT .)
    AND             reduce using rule 59 (expr -> INT .)
    OR              reduce using rule 59 (expr -> INT .)

  ! RPAREN          [ reduce using rule 59 (expr -> INT .) ]


state 74

    (20) type -> FLOAT .
    (60) expr -> FLOAT .

  ! reduce/reduce conflict for RPAREN resolved using rule 20 (type -> FLOAT .)
    RPAREN          reduce using rule 20 (type -> FLOAT .)
    PLUS            reduce using rule 60 (expr -> FLOAT .)
    MINUS           reduce using rule 60 (expr -> FLOAT .)
    TIMES           reduce using rule 60 (expr -> FLOAT .)
    DIVIDE          reduce using rule 60 (expr -> FLOAT .)
    MOD             reduce using rule 60 (expr -> FLOAT .)
    EQ              reduce using rule 60 (expr -> FLOAT .)
    NE              reduce using rule 60 (expr -> FLOAT .)
    LT              reduce using rule 60 (expr -> FLOAT .)
    LE              reduce using rule 60 (expr -> FLOAT .)
    GT              reduce using rule 60 (expr -> FLOAT .)
    GE              reduce using rule 60 (expr -> FLOAT .)
    AND             reduce using rule 60 (expr -> FLOAT .)
    OR              reduce using rule 60 (expr -> FLOAT .)

  ! RPAREN          [ reduce using rule 60 (expr -> FLOAT .) ]


state 75

    (21) type -> DOUBLE .
    (61) expr -> DOUBLE .

  ! reduce/reduce conflict for RPAREN resolved using rule 21 (type -> DOUBLE .)
    RPAREN          reduce using rule 21 (type -> DOUBLE .)
    PLUS            reduce using rule 61 (expr -> DOUBLE .)
    MINUS           reduce using rule 61 (expr -> DOUBLE .)
    TIMES           reduce using rule 61 (expr -> DOUBLE .)
    DIVIDE          reduce using rule 61 (expr -> DOUBLE .)
    MOD             reduce using rule 61 (expr -> DOUBLE .)
    EQ              reduce using rule 61 (expr -> DOUBLE .)
    NE              reduce using rule 61 (expr -> DOUBLE .)
    LT              reduce using rule 61 (expr -> DOUBLE .)
    LE              reduce using rule 61 (expr -> DOUBLE .)
    GT              reduce using rule 61 (expr -> DOUBLE .)
    GE              reduce using rule 61 (expr -> DOUBLE .)
    AND             reduce using rule 61 (expr -> DOUBLE .)
    OR              reduce using rule 61 (expr -> DOUBLE .)

  ! RPAREN          [ reduce using rule 61 (expr -> DOUBLE .) ]


state 76

    (24) type -> CHAR .
    (65) expr -> CHAR .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (type -> CHAR .)
    RPAREN          reduce using rule 24 (type -> CHAR .)
    PLUS            reduce using rule 65 (expr -> CHAR .)
    MINUS           reduce using rule 65 (expr -> CHAR .)
    TIMES           reduce using rule 65 (expr -> CHAR .)
    DIVIDE          reduce using rule 65 (expr -> CHAR .)
    MOD             reduce using rule 65 (expr -> CHAR .)
    EQ              reduce using rule 65 (expr -> CHAR .)
    NE              reduce using rule 65 (expr -> CHAR .)
    LT              reduce using rule 65 (expr -> CHAR .)
    LE              reduce using rule 65 (expr -> CHAR .)
    GT              reduce using rule 65 (expr -> CHAR .)
    GE              reduce using rule 65 (expr -> CHAR .)
    AND             reduce using rule 65 (expr -> CHAR .)
    OR              reduce using rule 65 (expr -> CHAR .)

  ! RPAREN          [ reduce using rule 65 (expr -> CHAR .) ]


state 77

    (57) expr -> MINUS expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 57 (expr -> MINUS expr .)
    PLUS            reduce using rule 57 (expr -> MINUS expr .)
    MINUS           reduce using rule 57 (expr -> MINUS expr .)
    TIMES           reduce using rule 57 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 57 (expr -> MINUS expr .)
    MOD             reduce using rule 57 (expr -> MINUS expr .)
    EQ              reduce using rule 57 (expr -> MINUS expr .)
    NE              reduce using rule 57 (expr -> MINUS expr .)
    LT              reduce using rule 57 (expr -> MINUS expr .)
    LE              reduce using rule 57 (expr -> MINUS expr .)
    GT              reduce using rule 57 (expr -> MINUS expr .)
    GE              reduce using rule 57 (expr -> MINUS expr .)
    AND             reduce using rule 57 (expr -> MINUS expr .)
    OR              reduce using rule 57 (expr -> MINUS expr .)
    RPAREN          reduce using rule 57 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 78

    (56) expr -> NOT expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 56 (expr -> NOT expr .)
    PLUS            reduce using rule 56 (expr -> NOT expr .)
    MINUS           reduce using rule 56 (expr -> NOT expr .)
    TIMES           reduce using rule 56 (expr -> NOT expr .)
    DIVIDE          reduce using rule 56 (expr -> NOT expr .)
    MOD             reduce using rule 56 (expr -> NOT expr .)
    EQ              reduce using rule 56 (expr -> NOT expr .)
    NE              reduce using rule 56 (expr -> NOT expr .)
    LT              reduce using rule 56 (expr -> NOT expr .)
    LE              reduce using rule 56 (expr -> NOT expr .)
    GT              reduce using rule 56 (expr -> NOT expr .)
    GE              reduce using rule 56 (expr -> NOT expr .)
    AND             reduce using rule 56 (expr -> NOT expr .)
    OR              reduce using rule 56 (expr -> NOT expr .)
    RPAREN          reduce using rule 56 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 79

    (18) param -> type ID .

    RPAREN          reduce using rule 18 (param -> type ID .)
    COMMA           reduce using rule 18 (param -> type ID .)


state 80

    (12) method_decl -> PUBLIC type ID LPAREN param_list RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 97


state 81

    (15) param_list -> param_list COMMA . param
    (18) param -> . type ID
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    param                          shift and go to state 98
    type                           shift and go to state 53

state 82

    (42) expr -> expr PLUS expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 42 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 42 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 42 (expr -> expr PLUS expr .)
    EQ              reduce using rule 42 (expr -> expr PLUS expr .)
    NE              reduce using rule 42 (expr -> expr PLUS expr .)
    LT              reduce using rule 42 (expr -> expr PLUS expr .)
    LE              reduce using rule 42 (expr -> expr PLUS expr .)
    GT              reduce using rule 42 (expr -> expr PLUS expr .)
    GE              reduce using rule 42 (expr -> expr PLUS expr .)
    AND             reduce using rule 42 (expr -> expr PLUS expr .)
    OR              reduce using rule 42 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 42 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! TIMES           [ reduce using rule 42 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 42 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 42 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 83

    (43) expr -> expr MINUS expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 43 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 43 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 43 (expr -> expr MINUS expr .)
    EQ              reduce using rule 43 (expr -> expr MINUS expr .)
    NE              reduce using rule 43 (expr -> expr MINUS expr .)
    LT              reduce using rule 43 (expr -> expr MINUS expr .)
    LE              reduce using rule 43 (expr -> expr MINUS expr .)
    GT              reduce using rule 43 (expr -> expr MINUS expr .)
    GE              reduce using rule 43 (expr -> expr MINUS expr .)
    AND             reduce using rule 43 (expr -> expr MINUS expr .)
    OR              reduce using rule 43 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 43 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! TIMES           [ reduce using rule 43 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 43 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 43 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 84

    (44) expr -> expr TIMES expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 44 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 44 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 44 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 44 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 44 (expr -> expr TIMES expr .)
    MOD             reduce using rule 44 (expr -> expr TIMES expr .)
    EQ              reduce using rule 44 (expr -> expr TIMES expr .)
    NE              reduce using rule 44 (expr -> expr TIMES expr .)
    LT              reduce using rule 44 (expr -> expr TIMES expr .)
    LE              reduce using rule 44 (expr -> expr TIMES expr .)
    GT              reduce using rule 44 (expr -> expr TIMES expr .)
    GE              reduce using rule 44 (expr -> expr TIMES expr .)
    AND             reduce using rule 44 (expr -> expr TIMES expr .)
    OR              reduce using rule 44 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 44 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 85

    (45) expr -> expr DIVIDE expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 45 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 45 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 45 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 45 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 45 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 45 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 45 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 45 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 45 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 45 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 45 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 45 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 45 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 45 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 45 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 86

    (46) expr -> expr MOD expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 46 (expr -> expr MOD expr .)
    PLUS            reduce using rule 46 (expr -> expr MOD expr .)
    MINUS           reduce using rule 46 (expr -> expr MOD expr .)
    TIMES           reduce using rule 46 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 46 (expr -> expr MOD expr .)
    MOD             reduce using rule 46 (expr -> expr MOD expr .)
    EQ              reduce using rule 46 (expr -> expr MOD expr .)
    NE              reduce using rule 46 (expr -> expr MOD expr .)
    LT              reduce using rule 46 (expr -> expr MOD expr .)
    LE              reduce using rule 46 (expr -> expr MOD expr .)
    GT              reduce using rule 46 (expr -> expr MOD expr .)
    GE              reduce using rule 46 (expr -> expr MOD expr .)
    AND             reduce using rule 46 (expr -> expr MOD expr .)
    OR              reduce using rule 46 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 46 (expr -> expr MOD expr .)

  ! PLUS            [ shift and go to state 58 ]
  ! MINUS           [ shift and go to state 59 ]
  ! TIMES           [ shift and go to state 60 ]
  ! DIVIDE          [ shift and go to state 61 ]
  ! MOD             [ shift and go to state 62 ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 87

    (47) expr -> expr EQ expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 47 (expr -> expr EQ expr .)
    EQ              reduce using rule 47 (expr -> expr EQ expr .)
    NE              reduce using rule 47 (expr -> expr EQ expr .)
    AND             reduce using rule 47 (expr -> expr EQ expr .)
    OR              reduce using rule 47 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 47 (expr -> expr EQ expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68

  ! PLUS            [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! LE              [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! GE              [ reduce using rule 47 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 88

    (48) expr -> expr NE expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 48 (expr -> expr NE expr .)
    EQ              reduce using rule 48 (expr -> expr NE expr .)
    NE              reduce using rule 48 (expr -> expr NE expr .)
    AND             reduce using rule 48 (expr -> expr NE expr .)
    OR              reduce using rule 48 (expr -> expr NE expr .)
    RPAREN          reduce using rule 48 (expr -> expr NE expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68

  ! PLUS            [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! MOD             [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! LT              [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! LE              [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! GT              [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! GE              [ reduce using rule 48 (expr -> expr NE expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 89

    (49) expr -> expr LT expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 49 (expr -> expr LT expr .)
    EQ              reduce using rule 49 (expr -> expr LT expr .)
    NE              reduce using rule 49 (expr -> expr LT expr .)
    LT              reduce using rule 49 (expr -> expr LT expr .)
    LE              reduce using rule 49 (expr -> expr LT expr .)
    GT              reduce using rule 49 (expr -> expr LT expr .)
    GE              reduce using rule 49 (expr -> expr LT expr .)
    AND             reduce using rule 49 (expr -> expr LT expr .)
    OR              reduce using rule 49 (expr -> expr LT expr .)
    RPAREN          reduce using rule 49 (expr -> expr LT expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 49 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 49 (expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 49 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 49 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 49 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 90

    (50) expr -> expr LE expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 50 (expr -> expr LE expr .)
    EQ              reduce using rule 50 (expr -> expr LE expr .)
    NE              reduce using rule 50 (expr -> expr LE expr .)
    LT              reduce using rule 50 (expr -> expr LE expr .)
    LE              reduce using rule 50 (expr -> expr LE expr .)
    GT              reduce using rule 50 (expr -> expr LE expr .)
    GE              reduce using rule 50 (expr -> expr LE expr .)
    AND             reduce using rule 50 (expr -> expr LE expr .)
    OR              reduce using rule 50 (expr -> expr LE expr .)
    RPAREN          reduce using rule 50 (expr -> expr LE expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> expr LE expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 91

    (51) expr -> expr GT expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 51 (expr -> expr GT expr .)
    EQ              reduce using rule 51 (expr -> expr GT expr .)
    NE              reduce using rule 51 (expr -> expr GT expr .)
    LT              reduce using rule 51 (expr -> expr GT expr .)
    LE              reduce using rule 51 (expr -> expr GT expr .)
    GT              reduce using rule 51 (expr -> expr GT expr .)
    GE              reduce using rule 51 (expr -> expr GT expr .)
    AND             reduce using rule 51 (expr -> expr GT expr .)
    OR              reduce using rule 51 (expr -> expr GT expr .)
    RPAREN          reduce using rule 51 (expr -> expr GT expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 92

    (52) expr -> expr GE expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 52 (expr -> expr GE expr .)
    EQ              reduce using rule 52 (expr -> expr GE expr .)
    NE              reduce using rule 52 (expr -> expr GE expr .)
    LT              reduce using rule 52 (expr -> expr GE expr .)
    LE              reduce using rule 52 (expr -> expr GE expr .)
    GT              reduce using rule 52 (expr -> expr GE expr .)
    GE              reduce using rule 52 (expr -> expr GE expr .)
    AND             reduce using rule 52 (expr -> expr GE expr .)
    OR              reduce using rule 52 (expr -> expr GE expr .)
    RPAREN          reduce using rule 52 (expr -> expr GE expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62

  ! PLUS            [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! MOD             [ reduce using rule 52 (expr -> expr GE expr .) ]
  ! EQ              [ shift and go to state 63 ]
  ! NE              [ shift and go to state 64 ]
  ! LT              [ shift and go to state 65 ]
  ! LE              [ shift and go to state 66 ]
  ! GT              [ shift and go to state 67 ]
  ! GE              [ shift and go to state 68 ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 93

    (53) expr -> expr AND expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 53 (expr -> expr AND expr .)
    AND             reduce using rule 53 (expr -> expr AND expr .)
    OR              reduce using rule 53 (expr -> expr AND expr .)
    RPAREN          reduce using rule 53 (expr -> expr AND expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68

  ! PLUS            [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! NE              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! LE              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! GE              [ reduce using rule 53 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 69 ]
  ! OR              [ shift and go to state 70 ]


state 94

    (54) expr -> expr OR expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       reduce using rule 54 (expr -> expr OR expr .)
    OR              reduce using rule 54 (expr -> expr OR expr .)
    RPAREN          reduce using rule 54 (expr -> expr OR expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69

  ! PLUS            [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! MOD             [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! NE              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! LE              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! GE              [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 54 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 70 ]


state 95

    (41) expr -> LPAREN type RPAREN . expr
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 99

state 96

    (55) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 55 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 55 (expr -> LPAREN expr RPAREN .)


state 97

    (12) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE . stmt_list RBRACE
    (28) stmt_list -> . stmt_list stmt
    (29) stmt_list -> . empty
    (66) empty -> .

    RBRACE          reduce using rule 66 (empty -> .)
    ID              reduce using rule 66 (empty -> .)
    IF              reduce using rule 66 (empty -> .)
    RETURN          reduce using rule 66 (empty -> .)
    FOR             reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    stmt_list                      shift and go to state 100
    empty                          shift and go to state 101

state 98

    (15) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 15 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 15 (param_list -> param_list COMMA param .)


state 99

    (41) expr -> LPAREN type RPAREN expr .
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
    SEMICOLON       reduce using rule 41 (expr -> LPAREN type RPAREN expr .)
    RPAREN          reduce using rule 41 (expr -> LPAREN type RPAREN expr .)
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70

  ! PLUS            [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! MINUS           [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! TIMES           [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! DIVIDE          [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! MOD             [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! EQ              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! NE              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! LT              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! LE              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! GT              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! GE              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! AND             [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]
  ! OR              [ reduce using rule 41 (expr -> LPAREN type RPAREN expr .) ]


state 100

    (12) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list . RBRACE
    (28) stmt_list -> stmt_list . stmt
    (30) stmt -> . var_decl
    (31) stmt -> . assign_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . for_stmt
    (13) var_decl -> . type ID EQUALS expr SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON
    (36) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (39) return_stmt -> . RETURN expr SEMICOLON
    (40) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RBRACE          shift and go to state 103
    ID              shift and go to state 102
    IF              shift and go to state 110
    RETURN          shift and go to state 111
    FOR             shift and go to state 112
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    type                           shift and go to state 22
    stmt                           shift and go to state 104
    var_decl                       shift and go to state 105
    assign_stmt                    shift and go to state 106
    if_stmt                        shift and go to state 107
    return_stmt                    shift and go to state 108
    for_stmt                       shift and go to state 109

state 101

    (29) stmt_list -> empty .

    RBRACE          reduce using rule 29 (stmt_list -> empty .)
    ID              reduce using rule 29 (stmt_list -> empty .)
    IF              reduce using rule 29 (stmt_list -> empty .)
    RETURN          reduce using rule 29 (stmt_list -> empty .)
    FOR             reduce using rule 29 (stmt_list -> empty .)
    INT             reduce using rule 29 (stmt_list -> empty .)
    FLOAT           reduce using rule 29 (stmt_list -> empty .)
    DOUBLE          reduce using rule 29 (stmt_list -> empty .)
    STRINGTYPE      reduce using rule 29 (stmt_list -> empty .)
    BOOL            reduce using rule 29 (stmt_list -> empty .)
    CHAR            reduce using rule 29 (stmt_list -> empty .)
    VOID            reduce using rule 29 (stmt_list -> empty .)
    VAR             reduce using rule 29 (stmt_list -> empty .)
    LIST            reduce using rule 29 (stmt_list -> empty .)


state 102

    (35) assign_stmt -> ID . EQUALS expr SEMICOLON

    EQUALS          shift and go to state 113


state 103

    (12) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PUBLIC          reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 12 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)


state 104

    (28) stmt_list -> stmt_list stmt .

    RBRACE          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 28 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 28 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 28 (stmt_list -> stmt_list stmt .)
    DOUBLE          reduce using rule 28 (stmt_list -> stmt_list stmt .)
    STRINGTYPE      reduce using rule 28 (stmt_list -> stmt_list stmt .)
    BOOL            reduce using rule 28 (stmt_list -> stmt_list stmt .)
    CHAR            reduce using rule 28 (stmt_list -> stmt_list stmt .)
    VOID            reduce using rule 28 (stmt_list -> stmt_list stmt .)
    VAR             reduce using rule 28 (stmt_list -> stmt_list stmt .)
    LIST            reduce using rule 28 (stmt_list -> stmt_list stmt .)


state 105

    (30) stmt -> var_decl .

    RBRACE          reduce using rule 30 (stmt -> var_decl .)
    ID              reduce using rule 30 (stmt -> var_decl .)
    IF              reduce using rule 30 (stmt -> var_decl .)
    RETURN          reduce using rule 30 (stmt -> var_decl .)
    FOR             reduce using rule 30 (stmt -> var_decl .)
    INT             reduce using rule 30 (stmt -> var_decl .)
    FLOAT           reduce using rule 30 (stmt -> var_decl .)
    DOUBLE          reduce using rule 30 (stmt -> var_decl .)
    STRINGTYPE      reduce using rule 30 (stmt -> var_decl .)
    BOOL            reduce using rule 30 (stmt -> var_decl .)
    CHAR            reduce using rule 30 (stmt -> var_decl .)
    VOID            reduce using rule 30 (stmt -> var_decl .)
    VAR             reduce using rule 30 (stmt -> var_decl .)
    LIST            reduce using rule 30 (stmt -> var_decl .)


state 106

    (31) stmt -> assign_stmt .

    RBRACE          reduce using rule 31 (stmt -> assign_stmt .)
    ID              reduce using rule 31 (stmt -> assign_stmt .)
    IF              reduce using rule 31 (stmt -> assign_stmt .)
    RETURN          reduce using rule 31 (stmt -> assign_stmt .)
    FOR             reduce using rule 31 (stmt -> assign_stmt .)
    INT             reduce using rule 31 (stmt -> assign_stmt .)
    FLOAT           reduce using rule 31 (stmt -> assign_stmt .)
    DOUBLE          reduce using rule 31 (stmt -> assign_stmt .)
    STRINGTYPE      reduce using rule 31 (stmt -> assign_stmt .)
    BOOL            reduce using rule 31 (stmt -> assign_stmt .)
    CHAR            reduce using rule 31 (stmt -> assign_stmt .)
    VOID            reduce using rule 31 (stmt -> assign_stmt .)
    VAR             reduce using rule 31 (stmt -> assign_stmt .)
    LIST            reduce using rule 31 (stmt -> assign_stmt .)


state 107

    (32) stmt -> if_stmt .

    RBRACE          reduce using rule 32 (stmt -> if_stmt .)
    ID              reduce using rule 32 (stmt -> if_stmt .)
    IF              reduce using rule 32 (stmt -> if_stmt .)
    RETURN          reduce using rule 32 (stmt -> if_stmt .)
    FOR             reduce using rule 32 (stmt -> if_stmt .)
    INT             reduce using rule 32 (stmt -> if_stmt .)
    FLOAT           reduce using rule 32 (stmt -> if_stmt .)
    DOUBLE          reduce using rule 32 (stmt -> if_stmt .)
    STRINGTYPE      reduce using rule 32 (stmt -> if_stmt .)
    BOOL            reduce using rule 32 (stmt -> if_stmt .)
    CHAR            reduce using rule 32 (stmt -> if_stmt .)
    VOID            reduce using rule 32 (stmt -> if_stmt .)
    VAR             reduce using rule 32 (stmt -> if_stmt .)
    LIST            reduce using rule 32 (stmt -> if_stmt .)


state 108

    (33) stmt -> return_stmt .

    RBRACE          reduce using rule 33 (stmt -> return_stmt .)
    ID              reduce using rule 33 (stmt -> return_stmt .)
    IF              reduce using rule 33 (stmt -> return_stmt .)
    RETURN          reduce using rule 33 (stmt -> return_stmt .)
    FOR             reduce using rule 33 (stmt -> return_stmt .)
    INT             reduce using rule 33 (stmt -> return_stmt .)
    FLOAT           reduce using rule 33 (stmt -> return_stmt .)
    DOUBLE          reduce using rule 33 (stmt -> return_stmt .)
    STRINGTYPE      reduce using rule 33 (stmt -> return_stmt .)
    BOOL            reduce using rule 33 (stmt -> return_stmt .)
    CHAR            reduce using rule 33 (stmt -> return_stmt .)
    VOID            reduce using rule 33 (stmt -> return_stmt .)
    VAR             reduce using rule 33 (stmt -> return_stmt .)
    LIST            reduce using rule 33 (stmt -> return_stmt .)


state 109

    (34) stmt -> for_stmt .

    RBRACE          reduce using rule 34 (stmt -> for_stmt .)
    ID              reduce using rule 34 (stmt -> for_stmt .)
    IF              reduce using rule 34 (stmt -> for_stmt .)
    RETURN          reduce using rule 34 (stmt -> for_stmt .)
    FOR             reduce using rule 34 (stmt -> for_stmt .)
    INT             reduce using rule 34 (stmt -> for_stmt .)
    FLOAT           reduce using rule 34 (stmt -> for_stmt .)
    DOUBLE          reduce using rule 34 (stmt -> for_stmt .)
    STRINGTYPE      reduce using rule 34 (stmt -> for_stmt .)
    BOOL            reduce using rule 34 (stmt -> for_stmt .)
    CHAR            reduce using rule 34 (stmt -> for_stmt .)
    VOID            reduce using rule 34 (stmt -> for_stmt .)
    VAR             reduce using rule 34 (stmt -> for_stmt .)
    LIST            reduce using rule 34 (stmt -> for_stmt .)


state 110

    (36) if_stmt -> IF . LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part

    LPAREN          shift and go to state 114


state 111

    (39) return_stmt -> RETURN . expr SEMICOLON
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 115

state 112

    (40) for_stmt -> FOR . LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 116


state 113

    (35) assign_stmt -> ID EQUALS . expr SEMICOLON
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 117

state 114

    (36) if_stmt -> IF LPAREN . expr RPAREN LBRACE stmt_list RBRACE else_part
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 118

state 115

    (39) return_stmt -> RETURN expr . SEMICOLON
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       shift and go to state 119
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 116

    (40) for_stmt -> FOR LPAREN . assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON

    ID              shift and go to state 102

    assign_stmt                    shift and go to state 120

state 117

    (35) assign_stmt -> ID EQUALS expr . SEMICOLON
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       shift and go to state 121
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 118

    (36) if_stmt -> IF LPAREN expr . RPAREN LBRACE stmt_list RBRACE else_part
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    RPAREN          shift and go to state 122
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 119

    (39) return_stmt -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    DOUBLE          reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    STRINGTYPE      reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    BOOL            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    VAR             reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)
    LIST            reduce using rule 39 (return_stmt -> RETURN expr SEMICOLON .)


state 120

    (40) for_stmt -> FOR LPAREN assign_stmt . expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (41) expr -> . LPAREN type RPAREN expr
    (42) expr -> . expr PLUS expr
    (43) expr -> . expr MINUS expr
    (44) expr -> . expr TIMES expr
    (45) expr -> . expr DIVIDE expr
    (46) expr -> . expr MOD expr
    (47) expr -> . expr EQ expr
    (48) expr -> . expr NE expr
    (49) expr -> . expr LT expr
    (50) expr -> . expr LE expr
    (51) expr -> . expr GT expr
    (52) expr -> . expr GE expr
    (53) expr -> . expr AND expr
    (54) expr -> . expr OR expr
    (55) expr -> . LPAREN expr RPAREN
    (56) expr -> . NOT expr
    (57) expr -> . MINUS expr
    (58) expr -> . ID
    (59) expr -> . INT
    (60) expr -> . FLOAT
    (61) expr -> . DOUBLE
    (62) expr -> . STRING
    (63) expr -> . TRUE
    (64) expr -> . FALSE
    (65) expr -> . CHAR

    LPAREN          shift and go to state 42
    NOT             shift and go to state 44
    MINUS           shift and go to state 43
    ID              shift and go to state 40
    INT             shift and go to state 45
    FLOAT           shift and go to state 46
    DOUBLE          shift and go to state 47
    STRING          shift and go to state 48
    TRUE            shift and go to state 49
    FALSE           shift and go to state 50
    CHAR            shift and go to state 51

    expr                           shift and go to state 123

state 121

    (35) assign_stmt -> ID EQUALS expr SEMICOLON .

    RBRACE          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    VAR             reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    LIST            reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    LPAREN          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    NOT             reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    MINUS           reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    TRUE            reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FALSE           reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    RPAREN          reduce using rule 35 (assign_stmt -> ID EQUALS expr SEMICOLON .)


state 122

    (36) if_stmt -> IF LPAREN expr RPAREN . LBRACE stmt_list RBRACE else_part

    LBRACE          shift and go to state 124


state 123

    (40) for_stmt -> FOR LPAREN assign_stmt expr . SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (42) expr -> expr . PLUS expr
    (43) expr -> expr . MINUS expr
    (44) expr -> expr . TIMES expr
    (45) expr -> expr . DIVIDE expr
    (46) expr -> expr . MOD expr
    (47) expr -> expr . EQ expr
    (48) expr -> expr . NE expr
    (49) expr -> expr . LT expr
    (50) expr -> expr . LE expr
    (51) expr -> expr . GT expr
    (52) expr -> expr . GE expr
    (53) expr -> expr . AND expr
    (54) expr -> expr . OR expr

    SEMICOLON       shift and go to state 125
    PLUS            shift and go to state 58
    MINUS           shift and go to state 59
    TIMES           shift and go to state 60
    DIVIDE          shift and go to state 61
    MOD             shift and go to state 62
    EQ              shift and go to state 63
    NE              shift and go to state 64
    LT              shift and go to state 65
    LE              shift and go to state 66
    GT              shift and go to state 67
    GE              shift and go to state 68
    AND             shift and go to state 69
    OR              shift and go to state 70


state 124

    (36) if_stmt -> IF LPAREN expr RPAREN LBRACE . stmt_list RBRACE else_part
    (28) stmt_list -> . stmt_list stmt
    (29) stmt_list -> . empty
    (66) empty -> .

    RBRACE          reduce using rule 66 (empty -> .)
    ID              reduce using rule 66 (empty -> .)
    IF              reduce using rule 66 (empty -> .)
    RETURN          reduce using rule 66 (empty -> .)
    FOR             reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    stmt_list                      shift and go to state 126
    empty                          shift and go to state 101

state 125

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON . assign_stmt RPAREN LBRACE stmt_list RBRACE
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON

    ID              shift and go to state 102

    assign_stmt                    shift and go to state 127

state 126

    (36) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list . RBRACE else_part
    (28) stmt_list -> stmt_list . stmt
    (30) stmt -> . var_decl
    (31) stmt -> . assign_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . for_stmt
    (13) var_decl -> . type ID EQUALS expr SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON
    (36) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (39) return_stmt -> . RETURN expr SEMICOLON
    (40) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RBRACE          shift and go to state 128
    ID              shift and go to state 102
    IF              shift and go to state 110
    RETURN          shift and go to state 111
    FOR             shift and go to state 112
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    stmt                           shift and go to state 104
    var_decl                       shift and go to state 105
    assign_stmt                    shift and go to state 106
    if_stmt                        shift and go to state 107
    return_stmt                    shift and go to state 108
    for_stmt                       shift and go to state 109
    type                           shift and go to state 22

state 127

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 129


state 128

    (36) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE . else_part
    (37) else_part -> . ELSE LBRACE stmt_list RBRACE
    (38) else_part -> . empty
    (66) empty -> .

    ELSE            shift and go to state 131
    RBRACE          reduce using rule 66 (empty -> .)
    ID              reduce using rule 66 (empty -> .)
    IF              reduce using rule 66 (empty -> .)
    RETURN          reduce using rule 66 (empty -> .)
    FOR             reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    else_part                      shift and go to state 130
    empty                          shift and go to state 132

state 129

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 133


state 130

    (36) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .

    RBRACE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    ID              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    IF              reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    RETURN          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    FOR             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    INT             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    FLOAT           reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    DOUBLE          reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    STRINGTYPE      reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    BOOL            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    CHAR            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    VOID            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    VAR             reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    LIST            reduce using rule 36 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)


state 131

    (37) else_part -> ELSE . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 134


state 132

    (38) else_part -> empty .

    RBRACE          reduce using rule 38 (else_part -> empty .)
    ID              reduce using rule 38 (else_part -> empty .)
    IF              reduce using rule 38 (else_part -> empty .)
    RETURN          reduce using rule 38 (else_part -> empty .)
    FOR             reduce using rule 38 (else_part -> empty .)
    INT             reduce using rule 38 (else_part -> empty .)
    FLOAT           reduce using rule 38 (else_part -> empty .)
    DOUBLE          reduce using rule 38 (else_part -> empty .)
    STRINGTYPE      reduce using rule 38 (else_part -> empty .)
    BOOL            reduce using rule 38 (else_part -> empty .)
    CHAR            reduce using rule 38 (else_part -> empty .)
    VOID            reduce using rule 38 (else_part -> empty .)
    VAR             reduce using rule 38 (else_part -> empty .)
    LIST            reduce using rule 38 (else_part -> empty .)


state 133

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE . stmt_list RBRACE
    (28) stmt_list -> . stmt_list stmt
    (29) stmt_list -> . empty
    (66) empty -> .

    RBRACE          reduce using rule 66 (empty -> .)
    ID              reduce using rule 66 (empty -> .)
    IF              reduce using rule 66 (empty -> .)
    RETURN          reduce using rule 66 (empty -> .)
    FOR             reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    stmt_list                      shift and go to state 135
    empty                          shift and go to state 101

state 134

    (37) else_part -> ELSE LBRACE . stmt_list RBRACE
    (28) stmt_list -> . stmt_list stmt
    (29) stmt_list -> . empty
    (66) empty -> .

    RBRACE          reduce using rule 66 (empty -> .)
    ID              reduce using rule 66 (empty -> .)
    IF              reduce using rule 66 (empty -> .)
    RETURN          reduce using rule 66 (empty -> .)
    FOR             reduce using rule 66 (empty -> .)
    INT             reduce using rule 66 (empty -> .)
    FLOAT           reduce using rule 66 (empty -> .)
    DOUBLE          reduce using rule 66 (empty -> .)
    STRINGTYPE      reduce using rule 66 (empty -> .)
    BOOL            reduce using rule 66 (empty -> .)
    CHAR            reduce using rule 66 (empty -> .)
    VOID            reduce using rule 66 (empty -> .)
    VAR             reduce using rule 66 (empty -> .)
    LIST            reduce using rule 66 (empty -> .)

    stmt_list                      shift and go to state 136
    empty                          shift and go to state 101

state 135

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list . RBRACE
    (28) stmt_list -> stmt_list . stmt
    (30) stmt -> . var_decl
    (31) stmt -> . assign_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . for_stmt
    (13) var_decl -> . type ID EQUALS expr SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON
    (36) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (39) return_stmt -> . RETURN expr SEMICOLON
    (40) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RBRACE          shift and go to state 137
    ID              shift and go to state 102
    IF              shift and go to state 110
    RETURN          shift and go to state 111
    FOR             shift and go to state 112
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    assign_stmt                    shift and go to state 106
    stmt                           shift and go to state 104
    var_decl                       shift and go to state 105
    if_stmt                        shift and go to state 107
    return_stmt                    shift and go to state 108
    for_stmt                       shift and go to state 109
    type                           shift and go to state 22

state 136

    (37) else_part -> ELSE LBRACE stmt_list . RBRACE
    (28) stmt_list -> stmt_list . stmt
    (30) stmt -> . var_decl
    (31) stmt -> . assign_stmt
    (32) stmt -> . if_stmt
    (33) stmt -> . return_stmt
    (34) stmt -> . for_stmt
    (13) var_decl -> . type ID EQUALS expr SEMICOLON
    (14) var_decl -> . type ID SEMICOLON
    (35) assign_stmt -> . ID EQUALS expr SEMICOLON
    (36) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (39) return_stmt -> . RETURN expr SEMICOLON
    (40) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (19) type -> . INT
    (20) type -> . FLOAT
    (21) type -> . DOUBLE
    (22) type -> . STRINGTYPE
    (23) type -> . BOOL
    (24) type -> . CHAR
    (25) type -> . VOID
    (26) type -> . VAR
    (27) type -> . LIST LT type GT

    RBRACE          shift and go to state 138
    ID              shift and go to state 102
    IF              shift and go to state 110
    RETURN          shift and go to state 111
    FOR             shift and go to state 112
    INT             shift and go to state 23
    FLOAT           shift and go to state 24
    DOUBLE          shift and go to state 25
    STRINGTYPE      shift and go to state 26
    BOOL            shift and go to state 27
    CHAR            shift and go to state 28
    VOID            shift and go to state 29
    VAR             shift and go to state 30
    LIST            shift and go to state 31

    stmt                           shift and go to state 104
    var_decl                       shift and go to state 105
    assign_stmt                    shift and go to state 106
    if_stmt                        shift and go to state 107
    return_stmt                    shift and go to state 108
    for_stmt                       shift and go to state 109
    type                           shift and go to state 22

state 137

    (40) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    ID              reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 40 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)


state 138

    (37) else_part -> ELSE LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    ID              reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    IF              reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    INT             reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 37 (else_part -> ELSE LBRACE stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 99 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 99 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 99 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 99 resolved as shift
WARNING: shift/reduce conflict for MOD in state 99 resolved as shift
WARNING: shift/reduce conflict for EQ in state 99 resolved as shift
WARNING: shift/reduce conflict for NE in state 99 resolved as shift
WARNING: shift/reduce conflict for LT in state 99 resolved as shift
WARNING: shift/reduce conflict for LE in state 99 resolved as shift
WARNING: shift/reduce conflict for GT in state 99 resolved as shift
WARNING: shift/reduce conflict for GE in state 99 resolved as shift
WARNING: shift/reduce conflict for AND in state 99 resolved as shift
WARNING: shift/reduce conflict for OR in state 99 resolved as shift
WARNING: reduce/reduce conflict in state 73 resolved using rule (type -> INT)
WARNING: rejected rule (expr -> INT) in state 73
WARNING: reduce/reduce conflict in state 74 resolved using rule (type -> FLOAT)
WARNING: rejected rule (expr -> FLOAT) in state 74
WARNING: reduce/reduce conflict in state 75 resolved using rule (type -> DOUBLE)
WARNING: rejected rule (expr -> DOUBLE) in state 75
WARNING: reduce/reduce conflict in state 76 resolved using rule (type -> CHAR)
WARNING: rejected rule (expr -> CHAR) in state 76
