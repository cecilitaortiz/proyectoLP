Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APOSTROPHE
    COMMENT
    PROTECTED
    QUOTE
    STATIC

Grammar

Rule 0     S' -> program
Rule 1     program -> using_list class_list
Rule 2     using_list -> using_list using_stmt
Rule 3     using_list -> empty
Rule 4     using_stmt -> USING ID SEMICOLON
Rule 5     class_list -> class_list class_decl
Rule 6     class_list -> class_decl
Rule 7     class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE
Rule 8     class_decl -> PRIVATE CLASS ID LBRACE member_list RBRACE
Rule 9     member_list -> member_list member
Rule 10    member_list -> empty
Rule 11    member -> method_decl
Rule 12    member -> var_decl
Rule 13    method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
Rule 14    method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
Rule 15    method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
Rule 16    var_decl -> type ID EQUALS expr SEMICOLON
Rule 17    var_decl -> type ID SEMICOLON
Rule 18    var_decl -> type ID LBRACKET RBRACKET SEMICOLON
Rule 19    var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
Rule 20    param_list -> param_list COMMA param
Rule 21    param_list -> param
Rule 22    param_list -> empty
Rule 23    param -> type ID
Rule 24    type -> INT
Rule 25    type -> FLOAT
Rule 26    type -> DOUBLE
Rule 27    type -> STRINGTYPE
Rule 28    type -> BOOL
Rule 29    type -> CHAR
Rule 30    type -> VOID
Rule 31    type -> VAR
Rule 32    type -> LIST LT type GT
Rule 33    stmt_list -> stmt_list stmt
Rule 34    stmt_list -> empty
Rule 35    stmt -> var_decl
Rule 36    stmt -> assign_stmt
Rule 37    stmt -> if_stmt
Rule 38    stmt -> return_stmt
Rule 39    stmt -> for_stmt
Rule 40    assign_stmt -> ID EQUALS expr SEMICOLON
Rule 41    if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
Rule 42    else_part -> ELSE LBRACE stmt_list RBRACE
Rule 43    else_part -> empty
Rule 44    return_stmt -> RETURN expr SEMICOLON
Rule 45    for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
Rule 46    stmt -> ID INCREMENT SEMICOLON
Rule 47    stmt -> ID DECREMENT SEMICOLON
Rule 48    stmt -> INCREMENT ID SEMICOLON
Rule 49    stmt -> DECREMENT ID SEMICOLON
Rule 50    expr -> LPAREN type RPAREN expr
Rule 51    expr -> expr PLUS expr
Rule 52    expr -> expr MINUS expr
Rule 53    expr -> expr TIMES expr
Rule 54    expr -> expr DIVIDE expr
Rule 55    expr -> expr MOD expr
Rule 56    expr -> expr EQ expr
Rule 57    expr -> expr NE expr
Rule 58    expr -> expr LT expr
Rule 59    expr -> expr LE expr
Rule 60    expr -> expr GT expr
Rule 61    expr -> expr GE expr
Rule 62    expr -> expr AND expr
Rule 63    expr -> expr OR expr
Rule 64    expr -> LPAREN expr RPAREN
Rule 65    expr -> NOT expr
Rule 66    expr -> MINUS expr
Rule 67    expr -> ID
Rule 68    expr -> INT
Rule 69    expr -> FLOAT
Rule 70    expr -> DOUBLE
Rule 71    expr -> STRING
Rule 72    expr -> TRUE
Rule 73    expr -> FALSE
Rule 74    expr -> CHAR
Rule 75    expr -> expr DOT ID
Rule 76    stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
Rule 77    stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
Rule 78    stmt -> BREAK SEMICOLON
Rule 79    stmt -> CONTINUE SEMICOLON
Rule 80    expr -> NULL
Rule 81    expr -> NEW type LPAREN param_list RPAREN
Rule 82    expr -> THIS
Rule 83    expr -> expr LBRACKET expr RBRACKET
Rule 84    expr -> expr PIPE expr
Rule 85    expr -> expr AMPERSAND expr
Rule 86    expr -> expr QUESTION expr COLON expr
Rule 87    assign_stmt -> ID PLUSEQ expr SEMICOLON
Rule 88    assign_stmt -> ID MINUSEQ expr SEMICOLON
Rule 89    assign_stmt -> ID TIMESEQ expr SEMICOLON
Rule 90    assign_stmt -> ID DIVEQ expr SEMICOLON
Rule 91    assign_stmt -> ID MODEQ expr SEMICOLON
Rule 92    expr -> param ARROW expr
Rule 93    empty -> <empty>

Terminals, with rules where they appear

AMPERSAND            : 85
AND                  : 62
APOSTROPHE           : 
ARROW                : 92
BOOL                 : 28
BREAK                : 78
CHAR                 : 29 74
CLASS                : 7 8
COLON                : 86
COMMA                : 20
COMMENT              : 
CONTINUE             : 79
DECREMENT            : 47 49
DIVEQ                : 90
DIVIDE               : 54
DO                   : 77
DOT                  : 75
DOUBLE               : 26 70
ELSE                 : 42
EQ                   : 56
EQUALS               : 16 19 40
FALSE                : 73
FLOAT                : 25 69
FOR                  : 45
GE                   : 61
GT                   : 32 60
ID                   : 4 7 8 13 14 15 16 17 18 19 23 40 46 47 48 49 67 75 87 88 89 90 91
IF                   : 41
INCREMENT            : 46 48
INT                  : 24 68
LBRACE               : 7 8 13 14 15 41 42 45 76 77
LBRACKET             : 18 19 83
LE                   : 59
LIST                 : 32
LPAREN               : 13 14 15 41 45 50 64 76 77 81
LT                   : 32 58
MINUS                : 52 66
MINUSEQ              : 88
MOD                  : 55
MODEQ                : 91
NE                   : 57
NEW                  : 81
NOT                  : 65
NULL                 : 80
OR                   : 63
PIPE                 : 84
PLUS                 : 51
PLUSEQ               : 87
PRIVATE              : 8 14
PROTECTED            : 
PUBLIC               : 7 13
QUESTION             : 86
QUOTE                : 
RBRACE               : 7 8 13 14 15 41 42 45 76 77
RBRACKET             : 18 19 83
RETURN               : 44
RPAREN               : 13 14 15 41 45 50 64 76 77 81
SEMICOLON            : 4 16 17 18 19 40 44 45 46 47 48 49 77 78 79 87 88 89 90 91
STATIC               : 
STRING               : 71
STRINGTYPE           : 27
THIS                 : 82
TIMES                : 53
TIMESEQ              : 89
TRUE                 : 72
USING                : 4
VAR                  : 31
VOID                 : 30
WHILE                : 76 77
error                : 

Nonterminals, with rules where they appear

assign_stmt          : 36 45 45
class_decl           : 5 6
class_list           : 1 5
else_part            : 41
empty                : 3 10 22 34 43
expr                 : 16 19 40 41 44 45 50 51 51 52 52 53 53 54 54 55 55 56 56 57 57 58 58 59 59 60 60 61 61 62 62 63 63 64 65 66 75 76 77 83 83 84 84 85 85 86 86 86 87 88 89 90 91 92
for_stmt             : 39
if_stmt              : 37
member               : 9
member_list          : 7 8 9
method_decl          : 11
param                : 20 21 92
param_list           : 13 14 15 20 81
program              : 0
return_stmt          : 38
stmt                 : 33
stmt_list            : 13 14 15 33 41 42 45 76 77
type                 : 13 14 15 16 17 18 19 23 32 50 81
using_list           : 1 2
using_stmt           : 2
var_decl             : 12 35

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . using_list class_list
    (2) using_list -> . using_list using_stmt
    (3) using_list -> . empty
    (93) empty -> .

    USING           reduce using rule 93 (empty -> .)
    PUBLIC          reduce using rule 93 (empty -> .)
    PRIVATE         reduce using rule 93 (empty -> .)

    program                        shift and go to state 1
    using_list                     shift and go to state 2
    empty                          shift and go to state 3

state 1

    (0) S' -> program .



state 2

    (1) program -> using_list . class_list
    (2) using_list -> using_list . using_stmt
    (5) class_list -> . class_list class_decl
    (6) class_list -> . class_decl
    (4) using_stmt -> . USING ID SEMICOLON
    (7) class_decl -> . PUBLIC CLASS ID LBRACE member_list RBRACE
    (8) class_decl -> . PRIVATE CLASS ID LBRACE member_list RBRACE

    USING           shift and go to state 7
    PUBLIC          shift and go to state 8
    PRIVATE         shift and go to state 9

    class_list                     shift and go to state 4
    using_stmt                     shift and go to state 5
    class_decl                     shift and go to state 6

state 3

    (3) using_list -> empty .

    USING           reduce using rule 3 (using_list -> empty .)
    PUBLIC          reduce using rule 3 (using_list -> empty .)
    PRIVATE         reduce using rule 3 (using_list -> empty .)


state 4

    (1) program -> using_list class_list .
    (5) class_list -> class_list . class_decl
    (7) class_decl -> . PUBLIC CLASS ID LBRACE member_list RBRACE
    (8) class_decl -> . PRIVATE CLASS ID LBRACE member_list RBRACE

    $end            reduce using rule 1 (program -> using_list class_list .)
    PUBLIC          shift and go to state 8
    PRIVATE         shift and go to state 9

    class_decl                     shift and go to state 10

state 5

    (2) using_list -> using_list using_stmt .

    USING           reduce using rule 2 (using_list -> using_list using_stmt .)
    PUBLIC          reduce using rule 2 (using_list -> using_list using_stmt .)
    PRIVATE         reduce using rule 2 (using_list -> using_list using_stmt .)


state 6

    (6) class_list -> class_decl .

    PUBLIC          reduce using rule 6 (class_list -> class_decl .)
    PRIVATE         reduce using rule 6 (class_list -> class_decl .)
    $end            reduce using rule 6 (class_list -> class_decl .)


state 7

    (4) using_stmt -> USING . ID SEMICOLON

    ID              shift and go to state 11


state 8

    (7) class_decl -> PUBLIC . CLASS ID LBRACE member_list RBRACE

    CLASS           shift and go to state 12


state 9

    (8) class_decl -> PRIVATE . CLASS ID LBRACE member_list RBRACE

    CLASS           shift and go to state 13


state 10

    (5) class_list -> class_list class_decl .

    PUBLIC          reduce using rule 5 (class_list -> class_list class_decl .)
    PRIVATE         reduce using rule 5 (class_list -> class_list class_decl .)
    $end            reduce using rule 5 (class_list -> class_list class_decl .)


state 11

    (4) using_stmt -> USING ID . SEMICOLON

    SEMICOLON       shift and go to state 14


state 12

    (7) class_decl -> PUBLIC CLASS . ID LBRACE member_list RBRACE

    ID              shift and go to state 15


state 13

    (8) class_decl -> PRIVATE CLASS . ID LBRACE member_list RBRACE

    ID              shift and go to state 16


state 14

    (4) using_stmt -> USING ID SEMICOLON .

    USING           reduce using rule 4 (using_stmt -> USING ID SEMICOLON .)
    PUBLIC          reduce using rule 4 (using_stmt -> USING ID SEMICOLON .)
    PRIVATE         reduce using rule 4 (using_stmt -> USING ID SEMICOLON .)


state 15

    (7) class_decl -> PUBLIC CLASS ID . LBRACE member_list RBRACE

    LBRACE          shift and go to state 17


state 16

    (8) class_decl -> PRIVATE CLASS ID . LBRACE member_list RBRACE

    LBRACE          shift and go to state 18


state 17

    (7) class_decl -> PUBLIC CLASS ID LBRACE . member_list RBRACE
    (9) member_list -> . member_list member
    (10) member_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    PUBLIC          reduce using rule 93 (empty -> .)
    PRIVATE         reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    member_list                    shift and go to state 19
    empty                          shift and go to state 20

state 18

    (8) class_decl -> PRIVATE CLASS ID LBRACE . member_list RBRACE
    (9) member_list -> . member_list member
    (10) member_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    PUBLIC          reduce using rule 93 (empty -> .)
    PRIVATE         reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    member_list                    shift and go to state 21
    empty                          shift and go to state 20

state 19

    (7) class_decl -> PUBLIC CLASS ID LBRACE member_list . RBRACE
    (9) member_list -> member_list . member
    (11) member -> . method_decl
    (12) member -> . var_decl
    (13) method_decl -> . PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (14) method_decl -> . PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (15) method_decl -> . type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 23
    PUBLIC          shift and go to state 22
    PRIVATE         shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    member                         shift and go to state 24
    method_decl                    shift and go to state 25
    var_decl                       shift and go to state 26
    type                           shift and go to state 27

state 20

    (10) member_list -> empty .

    RBRACE          reduce using rule 10 (member_list -> empty .)
    PUBLIC          reduce using rule 10 (member_list -> empty .)
    PRIVATE         reduce using rule 10 (member_list -> empty .)
    INT             reduce using rule 10 (member_list -> empty .)
    FLOAT           reduce using rule 10 (member_list -> empty .)
    DOUBLE          reduce using rule 10 (member_list -> empty .)
    STRINGTYPE      reduce using rule 10 (member_list -> empty .)
    BOOL            reduce using rule 10 (member_list -> empty .)
    CHAR            reduce using rule 10 (member_list -> empty .)
    VOID            reduce using rule 10 (member_list -> empty .)
    VAR             reduce using rule 10 (member_list -> empty .)
    LIST            reduce using rule 10 (member_list -> empty .)


state 21

    (8) class_decl -> PRIVATE CLASS ID LBRACE member_list . RBRACE
    (9) member_list -> member_list . member
    (11) member -> . method_decl
    (12) member -> . var_decl
    (13) method_decl -> . PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (14) method_decl -> . PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (15) method_decl -> . type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 38
    PUBLIC          shift and go to state 22
    PRIVATE         shift and go to state 28
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    member                         shift and go to state 24
    method_decl                    shift and go to state 25
    var_decl                       shift and go to state 26
    type                           shift and go to state 27

state 22

    (13) method_decl -> PUBLIC . type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 39

state 23

    (7) class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .

    PUBLIC          reduce using rule 7 (class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .)
    PRIVATE         reduce using rule 7 (class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .)
    $end            reduce using rule 7 (class_decl -> PUBLIC CLASS ID LBRACE member_list RBRACE .)


state 24

    (9) member_list -> member_list member .

    RBRACE          reduce using rule 9 (member_list -> member_list member .)
    PUBLIC          reduce using rule 9 (member_list -> member_list member .)
    PRIVATE         reduce using rule 9 (member_list -> member_list member .)
    INT             reduce using rule 9 (member_list -> member_list member .)
    FLOAT           reduce using rule 9 (member_list -> member_list member .)
    DOUBLE          reduce using rule 9 (member_list -> member_list member .)
    STRINGTYPE      reduce using rule 9 (member_list -> member_list member .)
    BOOL            reduce using rule 9 (member_list -> member_list member .)
    CHAR            reduce using rule 9 (member_list -> member_list member .)
    VOID            reduce using rule 9 (member_list -> member_list member .)
    VAR             reduce using rule 9 (member_list -> member_list member .)
    LIST            reduce using rule 9 (member_list -> member_list member .)


state 25

    (11) member -> method_decl .

    RBRACE          reduce using rule 11 (member -> method_decl .)
    PUBLIC          reduce using rule 11 (member -> method_decl .)
    PRIVATE         reduce using rule 11 (member -> method_decl .)
    INT             reduce using rule 11 (member -> method_decl .)
    FLOAT           reduce using rule 11 (member -> method_decl .)
    DOUBLE          reduce using rule 11 (member -> method_decl .)
    STRINGTYPE      reduce using rule 11 (member -> method_decl .)
    BOOL            reduce using rule 11 (member -> method_decl .)
    CHAR            reduce using rule 11 (member -> method_decl .)
    VOID            reduce using rule 11 (member -> method_decl .)
    VAR             reduce using rule 11 (member -> method_decl .)
    LIST            reduce using rule 11 (member -> method_decl .)


state 26

    (12) member -> var_decl .

    RBRACE          reduce using rule 12 (member -> var_decl .)
    PUBLIC          reduce using rule 12 (member -> var_decl .)
    PRIVATE         reduce using rule 12 (member -> var_decl .)
    INT             reduce using rule 12 (member -> var_decl .)
    FLOAT           reduce using rule 12 (member -> var_decl .)
    DOUBLE          reduce using rule 12 (member -> var_decl .)
    STRINGTYPE      reduce using rule 12 (member -> var_decl .)
    BOOL            reduce using rule 12 (member -> var_decl .)
    CHAR            reduce using rule 12 (member -> var_decl .)
    VOID            reduce using rule 12 (member -> var_decl .)
    VAR             reduce using rule 12 (member -> var_decl .)
    LIST            reduce using rule 12 (member -> var_decl .)


state 27

    (15) method_decl -> type . ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (16) var_decl -> type . ID EQUALS expr SEMICOLON
    (17) var_decl -> type . ID SEMICOLON
    (18) var_decl -> type . ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> type . ID LBRACKET RBRACKET EQUALS expr SEMICOLON

    ID              shift and go to state 40


state 28

    (14) method_decl -> PRIVATE . type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 41

state 29

    (24) type -> INT .

    ID              reduce using rule 24 (type -> INT .)
    GT              reduce using rule 24 (type -> INT .)
    LPAREN          reduce using rule 24 (type -> INT .)


state 30

    (25) type -> FLOAT .

    ID              reduce using rule 25 (type -> FLOAT .)
    GT              reduce using rule 25 (type -> FLOAT .)
    LPAREN          reduce using rule 25 (type -> FLOAT .)


state 31

    (26) type -> DOUBLE .

    ID              reduce using rule 26 (type -> DOUBLE .)
    GT              reduce using rule 26 (type -> DOUBLE .)
    LPAREN          reduce using rule 26 (type -> DOUBLE .)


state 32

    (27) type -> STRINGTYPE .

    ID              reduce using rule 27 (type -> STRINGTYPE .)
    GT              reduce using rule 27 (type -> STRINGTYPE .)
    RPAREN          reduce using rule 27 (type -> STRINGTYPE .)
    LPAREN          reduce using rule 27 (type -> STRINGTYPE .)


state 33

    (28) type -> BOOL .

    ID              reduce using rule 28 (type -> BOOL .)
    GT              reduce using rule 28 (type -> BOOL .)
    RPAREN          reduce using rule 28 (type -> BOOL .)
    LPAREN          reduce using rule 28 (type -> BOOL .)


state 34

    (29) type -> CHAR .

    ID              reduce using rule 29 (type -> CHAR .)
    GT              reduce using rule 29 (type -> CHAR .)
    LPAREN          reduce using rule 29 (type -> CHAR .)


state 35

    (30) type -> VOID .

    ID              reduce using rule 30 (type -> VOID .)
    GT              reduce using rule 30 (type -> VOID .)
    RPAREN          reduce using rule 30 (type -> VOID .)
    LPAREN          reduce using rule 30 (type -> VOID .)


state 36

    (31) type -> VAR .

    ID              reduce using rule 31 (type -> VAR .)
    GT              reduce using rule 31 (type -> VAR .)
    RPAREN          reduce using rule 31 (type -> VAR .)
    LPAREN          reduce using rule 31 (type -> VAR .)


state 37

    (32) type -> LIST . LT type GT

    LT              shift and go to state 42


state 38

    (8) class_decl -> PRIVATE CLASS ID LBRACE member_list RBRACE .

    PUBLIC          reduce using rule 8 (class_decl -> PRIVATE CLASS ID LBRACE member_list RBRACE .)
    PRIVATE         reduce using rule 8 (class_decl -> PRIVATE CLASS ID LBRACE member_list RBRACE .)
    $end            reduce using rule 8 (class_decl -> PRIVATE CLASS ID LBRACE member_list RBRACE .)


state 39

    (13) method_decl -> PUBLIC type . ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    ID              shift and go to state 43


state 40

    (15) method_decl -> type ID . LPAREN param_list RPAREN LBRACE stmt_list RBRACE
    (16) var_decl -> type ID . EQUALS expr SEMICOLON
    (17) var_decl -> type ID . SEMICOLON
    (18) var_decl -> type ID . LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> type ID . LBRACKET RBRACKET EQUALS expr SEMICOLON

    LPAREN          shift and go to state 44
    EQUALS          shift and go to state 45
    SEMICOLON       shift and go to state 46
    LBRACKET        shift and go to state 47


state 41

    (14) method_decl -> PRIVATE type . ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    ID              shift and go to state 48


state 42

    (32) type -> LIST LT . type GT
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 49

state 43

    (13) method_decl -> PUBLIC type ID . LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 50


state 44

    (15) method_decl -> type ID LPAREN . param_list RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> . param_list COMMA param
    (21) param_list -> . param
    (22) param_list -> . empty
    (23) param -> . type ID
    (93) empty -> .
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    param_list                     shift and go to state 52
    param                          shift and go to state 53
    empty                          shift and go to state 54

state 45

    (16) var_decl -> type ID EQUALS . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    expr                           shift and go to state 56
    param                          shift and go to state 70

state 46

    (17) var_decl -> type ID SEMICOLON .

    RBRACE          reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    PUBLIC          reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    PRIVATE         reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    INT             reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    FLOAT           reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    DOUBLE          reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    STRINGTYPE      reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    BOOL            reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    CHAR            reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    VOID            reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    VAR             reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    LIST            reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    ID              reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    INCREMENT       reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    DECREMENT       reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    WHILE           reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    DO              reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    BREAK           reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    CONTINUE        reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    IF              reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    RETURN          reduce using rule 17 (var_decl -> type ID SEMICOLON .)
    FOR             reduce using rule 17 (var_decl -> type ID SEMICOLON .)


state 47

    (18) var_decl -> type ID LBRACKET . RBRACKET SEMICOLON
    (19) var_decl -> type ID LBRACKET . RBRACKET EQUALS expr SEMICOLON

    RBRACKET        shift and go to state 71


state 48

    (14) method_decl -> PRIVATE type ID . LPAREN param_list RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 72


state 49

    (32) type -> LIST LT type . GT

    GT              shift and go to state 73


state 50

    (13) method_decl -> PUBLIC type ID LPAREN . param_list RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> . param_list COMMA param
    (21) param_list -> . param
    (22) param_list -> . empty
    (23) param -> . type ID
    (93) empty -> .
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    param_list                     shift and go to state 74
    param                          shift and go to state 53
    empty                          shift and go to state 54

state 51

    (23) param -> type . ID

    ID              shift and go to state 75


state 52

    (15) method_decl -> type ID LPAREN param_list . RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 76
    COMMA           shift and go to state 77


state 53

    (21) param_list -> param .

    RPAREN          reduce using rule 21 (param_list -> param .)
    COMMA           reduce using rule 21 (param_list -> param .)


state 54

    (22) param_list -> empty .

    RPAREN          reduce using rule 22 (param_list -> empty .)
    COMMA           reduce using rule 22 (param_list -> empty .)


state 55

    (67) expr -> ID .

    SEMICOLON       reduce using rule 67 (expr -> ID .)
    PLUS            reduce using rule 67 (expr -> ID .)
    MINUS           reduce using rule 67 (expr -> ID .)
    TIMES           reduce using rule 67 (expr -> ID .)
    DIVIDE          reduce using rule 67 (expr -> ID .)
    MOD             reduce using rule 67 (expr -> ID .)
    EQ              reduce using rule 67 (expr -> ID .)
    NE              reduce using rule 67 (expr -> ID .)
    LT              reduce using rule 67 (expr -> ID .)
    LE              reduce using rule 67 (expr -> ID .)
    GT              reduce using rule 67 (expr -> ID .)
    GE              reduce using rule 67 (expr -> ID .)
    AND             reduce using rule 67 (expr -> ID .)
    OR              reduce using rule 67 (expr -> ID .)
    DOT             reduce using rule 67 (expr -> ID .)
    LBRACKET        reduce using rule 67 (expr -> ID .)
    PIPE            reduce using rule 67 (expr -> ID .)
    AMPERSAND       reduce using rule 67 (expr -> ID .)
    QUESTION        reduce using rule 67 (expr -> ID .)
    RPAREN          reduce using rule 67 (expr -> ID .)
    RBRACKET        reduce using rule 67 (expr -> ID .)
    COLON           reduce using rule 67 (expr -> ID .)


state 56

    (16) var_decl -> type ID EQUALS expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 78
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 57

    (50) expr -> LPAREN . type RPAREN expr
    (64) expr -> LPAREN . expr RPAREN
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID

    INT             shift and go to state 99
    FLOAT           shift and go to state 100
    DOUBLE          shift and go to state 101
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 102
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37
    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69

    type                           shift and go to state 97
    expr                           shift and go to state 98
    param                          shift and go to state 70

state 58

    (66) expr -> MINUS . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 103
    type                           shift and go to state 51
    param                          shift and go to state 70

state 59

    (65) expr -> NOT . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 104
    type                           shift and go to state 51
    param                          shift and go to state 70

state 60

    (68) expr -> INT .
    (24) type -> INT .

    SEMICOLON       reduce using rule 68 (expr -> INT .)
    PLUS            reduce using rule 68 (expr -> INT .)
    MINUS           reduce using rule 68 (expr -> INT .)
    TIMES           reduce using rule 68 (expr -> INT .)
    DIVIDE          reduce using rule 68 (expr -> INT .)
    MOD             reduce using rule 68 (expr -> INT .)
    EQ              reduce using rule 68 (expr -> INT .)
    NE              reduce using rule 68 (expr -> INT .)
    LT              reduce using rule 68 (expr -> INT .)
    LE              reduce using rule 68 (expr -> INT .)
    GT              reduce using rule 68 (expr -> INT .)
    GE              reduce using rule 68 (expr -> INT .)
    AND             reduce using rule 68 (expr -> INT .)
    OR              reduce using rule 68 (expr -> INT .)
    DOT             reduce using rule 68 (expr -> INT .)
    LBRACKET        reduce using rule 68 (expr -> INT .)
    PIPE            reduce using rule 68 (expr -> INT .)
    AMPERSAND       reduce using rule 68 (expr -> INT .)
    QUESTION        reduce using rule 68 (expr -> INT .)
    RPAREN          reduce using rule 68 (expr -> INT .)
    RBRACKET        reduce using rule 68 (expr -> INT .)
    COLON           reduce using rule 68 (expr -> INT .)
    ID              reduce using rule 24 (type -> INT .)


state 61

    (69) expr -> FLOAT .
    (25) type -> FLOAT .

    SEMICOLON       reduce using rule 69 (expr -> FLOAT .)
    PLUS            reduce using rule 69 (expr -> FLOAT .)
    MINUS           reduce using rule 69 (expr -> FLOAT .)
    TIMES           reduce using rule 69 (expr -> FLOAT .)
    DIVIDE          reduce using rule 69 (expr -> FLOAT .)
    MOD             reduce using rule 69 (expr -> FLOAT .)
    EQ              reduce using rule 69 (expr -> FLOAT .)
    NE              reduce using rule 69 (expr -> FLOAT .)
    LT              reduce using rule 69 (expr -> FLOAT .)
    LE              reduce using rule 69 (expr -> FLOAT .)
    GT              reduce using rule 69 (expr -> FLOAT .)
    GE              reduce using rule 69 (expr -> FLOAT .)
    AND             reduce using rule 69 (expr -> FLOAT .)
    OR              reduce using rule 69 (expr -> FLOAT .)
    DOT             reduce using rule 69 (expr -> FLOAT .)
    LBRACKET        reduce using rule 69 (expr -> FLOAT .)
    PIPE            reduce using rule 69 (expr -> FLOAT .)
    AMPERSAND       reduce using rule 69 (expr -> FLOAT .)
    QUESTION        reduce using rule 69 (expr -> FLOAT .)
    RPAREN          reduce using rule 69 (expr -> FLOAT .)
    RBRACKET        reduce using rule 69 (expr -> FLOAT .)
    COLON           reduce using rule 69 (expr -> FLOAT .)
    ID              reduce using rule 25 (type -> FLOAT .)


state 62

    (70) expr -> DOUBLE .
    (26) type -> DOUBLE .

    SEMICOLON       reduce using rule 70 (expr -> DOUBLE .)
    PLUS            reduce using rule 70 (expr -> DOUBLE .)
    MINUS           reduce using rule 70 (expr -> DOUBLE .)
    TIMES           reduce using rule 70 (expr -> DOUBLE .)
    DIVIDE          reduce using rule 70 (expr -> DOUBLE .)
    MOD             reduce using rule 70 (expr -> DOUBLE .)
    EQ              reduce using rule 70 (expr -> DOUBLE .)
    NE              reduce using rule 70 (expr -> DOUBLE .)
    LT              reduce using rule 70 (expr -> DOUBLE .)
    LE              reduce using rule 70 (expr -> DOUBLE .)
    GT              reduce using rule 70 (expr -> DOUBLE .)
    GE              reduce using rule 70 (expr -> DOUBLE .)
    AND             reduce using rule 70 (expr -> DOUBLE .)
    OR              reduce using rule 70 (expr -> DOUBLE .)
    DOT             reduce using rule 70 (expr -> DOUBLE .)
    LBRACKET        reduce using rule 70 (expr -> DOUBLE .)
    PIPE            reduce using rule 70 (expr -> DOUBLE .)
    AMPERSAND       reduce using rule 70 (expr -> DOUBLE .)
    QUESTION        reduce using rule 70 (expr -> DOUBLE .)
    RPAREN          reduce using rule 70 (expr -> DOUBLE .)
    RBRACKET        reduce using rule 70 (expr -> DOUBLE .)
    COLON           reduce using rule 70 (expr -> DOUBLE .)
    ID              reduce using rule 26 (type -> DOUBLE .)


state 63

    (71) expr -> STRING .

    SEMICOLON       reduce using rule 71 (expr -> STRING .)
    PLUS            reduce using rule 71 (expr -> STRING .)
    MINUS           reduce using rule 71 (expr -> STRING .)
    TIMES           reduce using rule 71 (expr -> STRING .)
    DIVIDE          reduce using rule 71 (expr -> STRING .)
    MOD             reduce using rule 71 (expr -> STRING .)
    EQ              reduce using rule 71 (expr -> STRING .)
    NE              reduce using rule 71 (expr -> STRING .)
    LT              reduce using rule 71 (expr -> STRING .)
    LE              reduce using rule 71 (expr -> STRING .)
    GT              reduce using rule 71 (expr -> STRING .)
    GE              reduce using rule 71 (expr -> STRING .)
    AND             reduce using rule 71 (expr -> STRING .)
    OR              reduce using rule 71 (expr -> STRING .)
    DOT             reduce using rule 71 (expr -> STRING .)
    LBRACKET        reduce using rule 71 (expr -> STRING .)
    PIPE            reduce using rule 71 (expr -> STRING .)
    AMPERSAND       reduce using rule 71 (expr -> STRING .)
    QUESTION        reduce using rule 71 (expr -> STRING .)
    RPAREN          reduce using rule 71 (expr -> STRING .)
    RBRACKET        reduce using rule 71 (expr -> STRING .)
    COLON           reduce using rule 71 (expr -> STRING .)


state 64

    (72) expr -> TRUE .

    SEMICOLON       reduce using rule 72 (expr -> TRUE .)
    PLUS            reduce using rule 72 (expr -> TRUE .)
    MINUS           reduce using rule 72 (expr -> TRUE .)
    TIMES           reduce using rule 72 (expr -> TRUE .)
    DIVIDE          reduce using rule 72 (expr -> TRUE .)
    MOD             reduce using rule 72 (expr -> TRUE .)
    EQ              reduce using rule 72 (expr -> TRUE .)
    NE              reduce using rule 72 (expr -> TRUE .)
    LT              reduce using rule 72 (expr -> TRUE .)
    LE              reduce using rule 72 (expr -> TRUE .)
    GT              reduce using rule 72 (expr -> TRUE .)
    GE              reduce using rule 72 (expr -> TRUE .)
    AND             reduce using rule 72 (expr -> TRUE .)
    OR              reduce using rule 72 (expr -> TRUE .)
    DOT             reduce using rule 72 (expr -> TRUE .)
    LBRACKET        reduce using rule 72 (expr -> TRUE .)
    PIPE            reduce using rule 72 (expr -> TRUE .)
    AMPERSAND       reduce using rule 72 (expr -> TRUE .)
    QUESTION        reduce using rule 72 (expr -> TRUE .)
    RPAREN          reduce using rule 72 (expr -> TRUE .)
    RBRACKET        reduce using rule 72 (expr -> TRUE .)
    COLON           reduce using rule 72 (expr -> TRUE .)


state 65

    (73) expr -> FALSE .

    SEMICOLON       reduce using rule 73 (expr -> FALSE .)
    PLUS            reduce using rule 73 (expr -> FALSE .)
    MINUS           reduce using rule 73 (expr -> FALSE .)
    TIMES           reduce using rule 73 (expr -> FALSE .)
    DIVIDE          reduce using rule 73 (expr -> FALSE .)
    MOD             reduce using rule 73 (expr -> FALSE .)
    EQ              reduce using rule 73 (expr -> FALSE .)
    NE              reduce using rule 73 (expr -> FALSE .)
    LT              reduce using rule 73 (expr -> FALSE .)
    LE              reduce using rule 73 (expr -> FALSE .)
    GT              reduce using rule 73 (expr -> FALSE .)
    GE              reduce using rule 73 (expr -> FALSE .)
    AND             reduce using rule 73 (expr -> FALSE .)
    OR              reduce using rule 73 (expr -> FALSE .)
    DOT             reduce using rule 73 (expr -> FALSE .)
    LBRACKET        reduce using rule 73 (expr -> FALSE .)
    PIPE            reduce using rule 73 (expr -> FALSE .)
    AMPERSAND       reduce using rule 73 (expr -> FALSE .)
    QUESTION        reduce using rule 73 (expr -> FALSE .)
    RPAREN          reduce using rule 73 (expr -> FALSE .)
    RBRACKET        reduce using rule 73 (expr -> FALSE .)
    COLON           reduce using rule 73 (expr -> FALSE .)


state 66

    (74) expr -> CHAR .
    (29) type -> CHAR .

    SEMICOLON       reduce using rule 74 (expr -> CHAR .)
    PLUS            reduce using rule 74 (expr -> CHAR .)
    MINUS           reduce using rule 74 (expr -> CHAR .)
    TIMES           reduce using rule 74 (expr -> CHAR .)
    DIVIDE          reduce using rule 74 (expr -> CHAR .)
    MOD             reduce using rule 74 (expr -> CHAR .)
    EQ              reduce using rule 74 (expr -> CHAR .)
    NE              reduce using rule 74 (expr -> CHAR .)
    LT              reduce using rule 74 (expr -> CHAR .)
    LE              reduce using rule 74 (expr -> CHAR .)
    GT              reduce using rule 74 (expr -> CHAR .)
    GE              reduce using rule 74 (expr -> CHAR .)
    AND             reduce using rule 74 (expr -> CHAR .)
    OR              reduce using rule 74 (expr -> CHAR .)
    DOT             reduce using rule 74 (expr -> CHAR .)
    LBRACKET        reduce using rule 74 (expr -> CHAR .)
    PIPE            reduce using rule 74 (expr -> CHAR .)
    AMPERSAND       reduce using rule 74 (expr -> CHAR .)
    QUESTION        reduce using rule 74 (expr -> CHAR .)
    RPAREN          reduce using rule 74 (expr -> CHAR .)
    RBRACKET        reduce using rule 74 (expr -> CHAR .)
    COLON           reduce using rule 74 (expr -> CHAR .)
    ID              reduce using rule 29 (type -> CHAR .)


state 67

    (80) expr -> NULL .

    SEMICOLON       reduce using rule 80 (expr -> NULL .)
    PLUS            reduce using rule 80 (expr -> NULL .)
    MINUS           reduce using rule 80 (expr -> NULL .)
    TIMES           reduce using rule 80 (expr -> NULL .)
    DIVIDE          reduce using rule 80 (expr -> NULL .)
    MOD             reduce using rule 80 (expr -> NULL .)
    EQ              reduce using rule 80 (expr -> NULL .)
    NE              reduce using rule 80 (expr -> NULL .)
    LT              reduce using rule 80 (expr -> NULL .)
    LE              reduce using rule 80 (expr -> NULL .)
    GT              reduce using rule 80 (expr -> NULL .)
    GE              reduce using rule 80 (expr -> NULL .)
    AND             reduce using rule 80 (expr -> NULL .)
    OR              reduce using rule 80 (expr -> NULL .)
    DOT             reduce using rule 80 (expr -> NULL .)
    LBRACKET        reduce using rule 80 (expr -> NULL .)
    PIPE            reduce using rule 80 (expr -> NULL .)
    AMPERSAND       reduce using rule 80 (expr -> NULL .)
    QUESTION        reduce using rule 80 (expr -> NULL .)
    RPAREN          reduce using rule 80 (expr -> NULL .)
    RBRACKET        reduce using rule 80 (expr -> NULL .)
    COLON           reduce using rule 80 (expr -> NULL .)


state 68

    (81) expr -> NEW . type LPAREN param_list RPAREN
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 105

state 69

    (82) expr -> THIS .

    SEMICOLON       reduce using rule 82 (expr -> THIS .)
    PLUS            reduce using rule 82 (expr -> THIS .)
    MINUS           reduce using rule 82 (expr -> THIS .)
    TIMES           reduce using rule 82 (expr -> THIS .)
    DIVIDE          reduce using rule 82 (expr -> THIS .)
    MOD             reduce using rule 82 (expr -> THIS .)
    EQ              reduce using rule 82 (expr -> THIS .)
    NE              reduce using rule 82 (expr -> THIS .)
    LT              reduce using rule 82 (expr -> THIS .)
    LE              reduce using rule 82 (expr -> THIS .)
    GT              reduce using rule 82 (expr -> THIS .)
    GE              reduce using rule 82 (expr -> THIS .)
    AND             reduce using rule 82 (expr -> THIS .)
    OR              reduce using rule 82 (expr -> THIS .)
    DOT             reduce using rule 82 (expr -> THIS .)
    LBRACKET        reduce using rule 82 (expr -> THIS .)
    PIPE            reduce using rule 82 (expr -> THIS .)
    AMPERSAND       reduce using rule 82 (expr -> THIS .)
    QUESTION        reduce using rule 82 (expr -> THIS .)
    RPAREN          reduce using rule 82 (expr -> THIS .)
    RBRACKET        reduce using rule 82 (expr -> THIS .)
    COLON           reduce using rule 82 (expr -> THIS .)


state 70

    (92) expr -> param . ARROW expr

    ARROW           shift and go to state 106


state 71

    (18) var_decl -> type ID LBRACKET RBRACKET . SEMICOLON
    (19) var_decl -> type ID LBRACKET RBRACKET . EQUALS expr SEMICOLON

    SEMICOLON       shift and go to state 107
    EQUALS          shift and go to state 108


state 72

    (14) method_decl -> PRIVATE type ID LPAREN . param_list RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> . param_list COMMA param
    (21) param_list -> . param
    (22) param_list -> . empty
    (23) param -> . type ID
    (93) empty -> .
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    param_list                     shift and go to state 109
    param                          shift and go to state 53
    empty                          shift and go to state 54

state 73

    (32) type -> LIST LT type GT .

    ID              reduce using rule 32 (type -> LIST LT type GT .)
    GT              reduce using rule 32 (type -> LIST LT type GT .)
    RPAREN          reduce using rule 32 (type -> LIST LT type GT .)
    LPAREN          reduce using rule 32 (type -> LIST LT type GT .)


state 74

    (13) method_decl -> PUBLIC type ID LPAREN param_list . RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 110
    COMMA           shift and go to state 77


state 75

    (23) param -> type ID .

    RPAREN          reduce using rule 23 (param -> type ID .)
    COMMA           reduce using rule 23 (param -> type ID .)
    ARROW           reduce using rule 23 (param -> type ID .)


state 76

    (15) method_decl -> type ID LPAREN param_list RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 111


state 77

    (20) param_list -> param_list COMMA . param
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    param                          shift and go to state 112
    type                           shift and go to state 51

state 78

    (16) var_decl -> type ID EQUALS expr SEMICOLON .

    RBRACE          reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    PUBLIC          reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    VAR             reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    LIST            reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    INCREMENT       reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    DECREMENT       reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    DO              reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    BREAK           reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    CONTINUE        reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 16 (var_decl -> type ID EQUALS expr SEMICOLON .)


state 79

    (51) expr -> expr PLUS . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 113
    type                           shift and go to state 51
    param                          shift and go to state 70

state 80

    (52) expr -> expr MINUS . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 114
    type                           shift and go to state 51
    param                          shift and go to state 70

state 81

    (53) expr -> expr TIMES . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 115
    type                           shift and go to state 51
    param                          shift and go to state 70

state 82

    (54) expr -> expr DIVIDE . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 116
    type                           shift and go to state 51
    param                          shift and go to state 70

state 83

    (55) expr -> expr MOD . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 117
    type                           shift and go to state 51
    param                          shift and go to state 70

state 84

    (56) expr -> expr EQ . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 118
    type                           shift and go to state 51
    param                          shift and go to state 70

state 85

    (57) expr -> expr NE . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 119
    type                           shift and go to state 51
    param                          shift and go to state 70

state 86

    (58) expr -> expr LT . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 120
    type                           shift and go to state 51
    param                          shift and go to state 70

state 87

    (59) expr -> expr LE . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 121
    type                           shift and go to state 51
    param                          shift and go to state 70

state 88

    (60) expr -> expr GT . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 122
    type                           shift and go to state 51
    param                          shift and go to state 70

state 89

    (61) expr -> expr GE . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 123
    type                           shift and go to state 51
    param                          shift and go to state 70

state 90

    (62) expr -> expr AND . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 124
    type                           shift and go to state 51
    param                          shift and go to state 70

state 91

    (63) expr -> expr OR . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 125
    type                           shift and go to state 51
    param                          shift and go to state 70

state 92

    (75) expr -> expr DOT . ID

    ID              shift and go to state 126


state 93

    (83) expr -> expr LBRACKET . expr RBRACKET
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 127
    type                           shift and go to state 51
    param                          shift and go to state 70

state 94

    (84) expr -> expr PIPE . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 128
    type                           shift and go to state 51
    param                          shift and go to state 70

state 95

    (85) expr -> expr AMPERSAND . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 129
    type                           shift and go to state 51
    param                          shift and go to state 70

state 96

    (86) expr -> expr QUESTION . expr COLON expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 130
    type                           shift and go to state 51
    param                          shift and go to state 70

state 97

    (50) expr -> LPAREN type . RPAREN expr
    (23) param -> type . ID

    RPAREN          shift and go to state 131
    ID              shift and go to state 75


state 98

    (64) expr -> LPAREN expr . RPAREN
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    RPAREN          shift and go to state 132
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 99

    (24) type -> INT .
    (68) expr -> INT .

  ! reduce/reduce conflict for RPAREN resolved using rule 24 (type -> INT .)
    RPAREN          reduce using rule 24 (type -> INT .)
    ID              reduce using rule 24 (type -> INT .)
    PLUS            reduce using rule 68 (expr -> INT .)
    MINUS           reduce using rule 68 (expr -> INT .)
    TIMES           reduce using rule 68 (expr -> INT .)
    DIVIDE          reduce using rule 68 (expr -> INT .)
    MOD             reduce using rule 68 (expr -> INT .)
    EQ              reduce using rule 68 (expr -> INT .)
    NE              reduce using rule 68 (expr -> INT .)
    LT              reduce using rule 68 (expr -> INT .)
    LE              reduce using rule 68 (expr -> INT .)
    GT              reduce using rule 68 (expr -> INT .)
    GE              reduce using rule 68 (expr -> INT .)
    AND             reduce using rule 68 (expr -> INT .)
    OR              reduce using rule 68 (expr -> INT .)
    DOT             reduce using rule 68 (expr -> INT .)
    LBRACKET        reduce using rule 68 (expr -> INT .)
    PIPE            reduce using rule 68 (expr -> INT .)
    AMPERSAND       reduce using rule 68 (expr -> INT .)
    QUESTION        reduce using rule 68 (expr -> INT .)

  ! RPAREN          [ reduce using rule 68 (expr -> INT .) ]


state 100

    (25) type -> FLOAT .
    (69) expr -> FLOAT .

  ! reduce/reduce conflict for RPAREN resolved using rule 25 (type -> FLOAT .)
    RPAREN          reduce using rule 25 (type -> FLOAT .)
    ID              reduce using rule 25 (type -> FLOAT .)
    PLUS            reduce using rule 69 (expr -> FLOAT .)
    MINUS           reduce using rule 69 (expr -> FLOAT .)
    TIMES           reduce using rule 69 (expr -> FLOAT .)
    DIVIDE          reduce using rule 69 (expr -> FLOAT .)
    MOD             reduce using rule 69 (expr -> FLOAT .)
    EQ              reduce using rule 69 (expr -> FLOAT .)
    NE              reduce using rule 69 (expr -> FLOAT .)
    LT              reduce using rule 69 (expr -> FLOAT .)
    LE              reduce using rule 69 (expr -> FLOAT .)
    GT              reduce using rule 69 (expr -> FLOAT .)
    GE              reduce using rule 69 (expr -> FLOAT .)
    AND             reduce using rule 69 (expr -> FLOAT .)
    OR              reduce using rule 69 (expr -> FLOAT .)
    DOT             reduce using rule 69 (expr -> FLOAT .)
    LBRACKET        reduce using rule 69 (expr -> FLOAT .)
    PIPE            reduce using rule 69 (expr -> FLOAT .)
    AMPERSAND       reduce using rule 69 (expr -> FLOAT .)
    QUESTION        reduce using rule 69 (expr -> FLOAT .)

  ! RPAREN          [ reduce using rule 69 (expr -> FLOAT .) ]


state 101

    (26) type -> DOUBLE .
    (70) expr -> DOUBLE .

  ! reduce/reduce conflict for RPAREN resolved using rule 26 (type -> DOUBLE .)
    RPAREN          reduce using rule 26 (type -> DOUBLE .)
    ID              reduce using rule 26 (type -> DOUBLE .)
    PLUS            reduce using rule 70 (expr -> DOUBLE .)
    MINUS           reduce using rule 70 (expr -> DOUBLE .)
    TIMES           reduce using rule 70 (expr -> DOUBLE .)
    DIVIDE          reduce using rule 70 (expr -> DOUBLE .)
    MOD             reduce using rule 70 (expr -> DOUBLE .)
    EQ              reduce using rule 70 (expr -> DOUBLE .)
    NE              reduce using rule 70 (expr -> DOUBLE .)
    LT              reduce using rule 70 (expr -> DOUBLE .)
    LE              reduce using rule 70 (expr -> DOUBLE .)
    GT              reduce using rule 70 (expr -> DOUBLE .)
    GE              reduce using rule 70 (expr -> DOUBLE .)
    AND             reduce using rule 70 (expr -> DOUBLE .)
    OR              reduce using rule 70 (expr -> DOUBLE .)
    DOT             reduce using rule 70 (expr -> DOUBLE .)
    LBRACKET        reduce using rule 70 (expr -> DOUBLE .)
    PIPE            reduce using rule 70 (expr -> DOUBLE .)
    AMPERSAND       reduce using rule 70 (expr -> DOUBLE .)
    QUESTION        reduce using rule 70 (expr -> DOUBLE .)

  ! RPAREN          [ reduce using rule 70 (expr -> DOUBLE .) ]


state 102

    (29) type -> CHAR .
    (74) expr -> CHAR .

  ! reduce/reduce conflict for RPAREN resolved using rule 29 (type -> CHAR .)
    RPAREN          reduce using rule 29 (type -> CHAR .)
    ID              reduce using rule 29 (type -> CHAR .)
    PLUS            reduce using rule 74 (expr -> CHAR .)
    MINUS           reduce using rule 74 (expr -> CHAR .)
    TIMES           reduce using rule 74 (expr -> CHAR .)
    DIVIDE          reduce using rule 74 (expr -> CHAR .)
    MOD             reduce using rule 74 (expr -> CHAR .)
    EQ              reduce using rule 74 (expr -> CHAR .)
    NE              reduce using rule 74 (expr -> CHAR .)
    LT              reduce using rule 74 (expr -> CHAR .)
    LE              reduce using rule 74 (expr -> CHAR .)
    GT              reduce using rule 74 (expr -> CHAR .)
    GE              reduce using rule 74 (expr -> CHAR .)
    AND             reduce using rule 74 (expr -> CHAR .)
    OR              reduce using rule 74 (expr -> CHAR .)
    DOT             reduce using rule 74 (expr -> CHAR .)
    LBRACKET        reduce using rule 74 (expr -> CHAR .)
    PIPE            reduce using rule 74 (expr -> CHAR .)
    AMPERSAND       reduce using rule 74 (expr -> CHAR .)
    QUESTION        reduce using rule 74 (expr -> CHAR .)

  ! RPAREN          [ reduce using rule 74 (expr -> CHAR .) ]


state 103

    (66) expr -> MINUS expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 66 (expr -> MINUS expr .)
    PLUS            reduce using rule 66 (expr -> MINUS expr .)
    MINUS           reduce using rule 66 (expr -> MINUS expr .)
    TIMES           reduce using rule 66 (expr -> MINUS expr .)
    DIVIDE          reduce using rule 66 (expr -> MINUS expr .)
    MOD             reduce using rule 66 (expr -> MINUS expr .)
    EQ              reduce using rule 66 (expr -> MINUS expr .)
    NE              reduce using rule 66 (expr -> MINUS expr .)
    LT              reduce using rule 66 (expr -> MINUS expr .)
    LE              reduce using rule 66 (expr -> MINUS expr .)
    GT              reduce using rule 66 (expr -> MINUS expr .)
    GE              reduce using rule 66 (expr -> MINUS expr .)
    AND             reduce using rule 66 (expr -> MINUS expr .)
    OR              reduce using rule 66 (expr -> MINUS expr .)
    DOT             reduce using rule 66 (expr -> MINUS expr .)
    LBRACKET        reduce using rule 66 (expr -> MINUS expr .)
    PIPE            reduce using rule 66 (expr -> MINUS expr .)
    AMPERSAND       reduce using rule 66 (expr -> MINUS expr .)
    QUESTION        reduce using rule 66 (expr -> MINUS expr .)
    RPAREN          reduce using rule 66 (expr -> MINUS expr .)
    RBRACKET        reduce using rule 66 (expr -> MINUS expr .)
    COLON           reduce using rule 66 (expr -> MINUS expr .)

  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MOD             [ shift and go to state 83 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 104

    (65) expr -> NOT expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 65 (expr -> NOT expr .)
    PLUS            reduce using rule 65 (expr -> NOT expr .)
    MINUS           reduce using rule 65 (expr -> NOT expr .)
    TIMES           reduce using rule 65 (expr -> NOT expr .)
    DIVIDE          reduce using rule 65 (expr -> NOT expr .)
    MOD             reduce using rule 65 (expr -> NOT expr .)
    EQ              reduce using rule 65 (expr -> NOT expr .)
    NE              reduce using rule 65 (expr -> NOT expr .)
    LT              reduce using rule 65 (expr -> NOT expr .)
    LE              reduce using rule 65 (expr -> NOT expr .)
    GT              reduce using rule 65 (expr -> NOT expr .)
    GE              reduce using rule 65 (expr -> NOT expr .)
    AND             reduce using rule 65 (expr -> NOT expr .)
    OR              reduce using rule 65 (expr -> NOT expr .)
    DOT             reduce using rule 65 (expr -> NOT expr .)
    LBRACKET        reduce using rule 65 (expr -> NOT expr .)
    PIPE            reduce using rule 65 (expr -> NOT expr .)
    AMPERSAND       reduce using rule 65 (expr -> NOT expr .)
    QUESTION        reduce using rule 65 (expr -> NOT expr .)
    RPAREN          reduce using rule 65 (expr -> NOT expr .)
    RBRACKET        reduce using rule 65 (expr -> NOT expr .)
    COLON           reduce using rule 65 (expr -> NOT expr .)

  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MOD             [ shift and go to state 83 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 105

    (81) expr -> NEW type . LPAREN param_list RPAREN

    LPAREN          shift and go to state 133


state 106

    (92) expr -> param ARROW . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    param                          shift and go to state 70
    expr                           shift and go to state 134
    type                           shift and go to state 51

state 107

    (18) var_decl -> type ID LBRACKET RBRACKET SEMICOLON .

    RBRACE          reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    PUBLIC          reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    PRIVATE         reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    INT             reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    FLOAT           reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    DOUBLE          reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    STRINGTYPE      reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    BOOL            reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    CHAR            reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    VOID            reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    VAR             reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    LIST            reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    ID              reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    INCREMENT       reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    DECREMENT       reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    WHILE           reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    DO              reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    BREAK           reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    CONTINUE        reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    IF              reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    RETURN          reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)
    FOR             reduce using rule 18 (var_decl -> type ID LBRACKET RBRACKET SEMICOLON .)


state 108

    (19) var_decl -> type ID LBRACKET RBRACKET EQUALS . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    expr                           shift and go to state 135
    param                          shift and go to state 70

state 109

    (14) method_decl -> PRIVATE type ID LPAREN param_list . RPAREN LBRACE stmt_list RBRACE
    (20) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 136
    COMMA           shift and go to state 77


state 110

    (13) method_decl -> PUBLIC type ID LPAREN param_list RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 137


state 111

    (15) method_decl -> type ID LPAREN param_list RPAREN LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 138
    empty                          shift and go to state 139

state 112

    (20) param_list -> param_list COMMA param .

    RPAREN          reduce using rule 20 (param_list -> param_list COMMA param .)
    COMMA           reduce using rule 20 (param_list -> param_list COMMA param .)


state 113

    (51) expr -> expr PLUS expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 51 (expr -> expr PLUS expr .)
    PLUS            reduce using rule 51 (expr -> expr PLUS expr .)
    MINUS           reduce using rule 51 (expr -> expr PLUS expr .)
    EQ              reduce using rule 51 (expr -> expr PLUS expr .)
    NE              reduce using rule 51 (expr -> expr PLUS expr .)
    LT              reduce using rule 51 (expr -> expr PLUS expr .)
    LE              reduce using rule 51 (expr -> expr PLUS expr .)
    GT              reduce using rule 51 (expr -> expr PLUS expr .)
    GE              reduce using rule 51 (expr -> expr PLUS expr .)
    AND             reduce using rule 51 (expr -> expr PLUS expr .)
    OR              reduce using rule 51 (expr -> expr PLUS expr .)
    DOT             reduce using rule 51 (expr -> expr PLUS expr .)
    LBRACKET        reduce using rule 51 (expr -> expr PLUS expr .)
    PIPE            reduce using rule 51 (expr -> expr PLUS expr .)
    AMPERSAND       reduce using rule 51 (expr -> expr PLUS expr .)
    QUESTION        reduce using rule 51 (expr -> expr PLUS expr .)
    RPAREN          reduce using rule 51 (expr -> expr PLUS expr .)
    RBRACKET        reduce using rule 51 (expr -> expr PLUS expr .)
    COLON           reduce using rule 51 (expr -> expr PLUS expr .)
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! TIMES           [ reduce using rule 51 (expr -> expr PLUS expr .) ]
  ! DIVIDE          [ reduce using rule 51 (expr -> expr PLUS expr .) ]
  ! MOD             [ reduce using rule 51 (expr -> expr PLUS expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 114

    (52) expr -> expr MINUS expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 52 (expr -> expr MINUS expr .)
    PLUS            reduce using rule 52 (expr -> expr MINUS expr .)
    MINUS           reduce using rule 52 (expr -> expr MINUS expr .)
    EQ              reduce using rule 52 (expr -> expr MINUS expr .)
    NE              reduce using rule 52 (expr -> expr MINUS expr .)
    LT              reduce using rule 52 (expr -> expr MINUS expr .)
    LE              reduce using rule 52 (expr -> expr MINUS expr .)
    GT              reduce using rule 52 (expr -> expr MINUS expr .)
    GE              reduce using rule 52 (expr -> expr MINUS expr .)
    AND             reduce using rule 52 (expr -> expr MINUS expr .)
    OR              reduce using rule 52 (expr -> expr MINUS expr .)
    DOT             reduce using rule 52 (expr -> expr MINUS expr .)
    LBRACKET        reduce using rule 52 (expr -> expr MINUS expr .)
    PIPE            reduce using rule 52 (expr -> expr MINUS expr .)
    AMPERSAND       reduce using rule 52 (expr -> expr MINUS expr .)
    QUESTION        reduce using rule 52 (expr -> expr MINUS expr .)
    RPAREN          reduce using rule 52 (expr -> expr MINUS expr .)
    RBRACKET        reduce using rule 52 (expr -> expr MINUS expr .)
    COLON           reduce using rule 52 (expr -> expr MINUS expr .)
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! TIMES           [ reduce using rule 52 (expr -> expr MINUS expr .) ]
  ! DIVIDE          [ reduce using rule 52 (expr -> expr MINUS expr .) ]
  ! MOD             [ reduce using rule 52 (expr -> expr MINUS expr .) ]
  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 115

    (53) expr -> expr TIMES expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 53 (expr -> expr TIMES expr .)
    PLUS            reduce using rule 53 (expr -> expr TIMES expr .)
    MINUS           reduce using rule 53 (expr -> expr TIMES expr .)
    TIMES           reduce using rule 53 (expr -> expr TIMES expr .)
    DIVIDE          reduce using rule 53 (expr -> expr TIMES expr .)
    MOD             reduce using rule 53 (expr -> expr TIMES expr .)
    EQ              reduce using rule 53 (expr -> expr TIMES expr .)
    NE              reduce using rule 53 (expr -> expr TIMES expr .)
    LT              reduce using rule 53 (expr -> expr TIMES expr .)
    LE              reduce using rule 53 (expr -> expr TIMES expr .)
    GT              reduce using rule 53 (expr -> expr TIMES expr .)
    GE              reduce using rule 53 (expr -> expr TIMES expr .)
    AND             reduce using rule 53 (expr -> expr TIMES expr .)
    OR              reduce using rule 53 (expr -> expr TIMES expr .)
    DOT             reduce using rule 53 (expr -> expr TIMES expr .)
    LBRACKET        reduce using rule 53 (expr -> expr TIMES expr .)
    PIPE            reduce using rule 53 (expr -> expr TIMES expr .)
    AMPERSAND       reduce using rule 53 (expr -> expr TIMES expr .)
    QUESTION        reduce using rule 53 (expr -> expr TIMES expr .)
    RPAREN          reduce using rule 53 (expr -> expr TIMES expr .)
    RBRACKET        reduce using rule 53 (expr -> expr TIMES expr .)
    COLON           reduce using rule 53 (expr -> expr TIMES expr .)

  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MOD             [ shift and go to state 83 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 116

    (54) expr -> expr DIVIDE expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 54 (expr -> expr DIVIDE expr .)
    PLUS            reduce using rule 54 (expr -> expr DIVIDE expr .)
    MINUS           reduce using rule 54 (expr -> expr DIVIDE expr .)
    TIMES           reduce using rule 54 (expr -> expr DIVIDE expr .)
    DIVIDE          reduce using rule 54 (expr -> expr DIVIDE expr .)
    MOD             reduce using rule 54 (expr -> expr DIVIDE expr .)
    EQ              reduce using rule 54 (expr -> expr DIVIDE expr .)
    NE              reduce using rule 54 (expr -> expr DIVIDE expr .)
    LT              reduce using rule 54 (expr -> expr DIVIDE expr .)
    LE              reduce using rule 54 (expr -> expr DIVIDE expr .)
    GT              reduce using rule 54 (expr -> expr DIVIDE expr .)
    GE              reduce using rule 54 (expr -> expr DIVIDE expr .)
    AND             reduce using rule 54 (expr -> expr DIVIDE expr .)
    OR              reduce using rule 54 (expr -> expr DIVIDE expr .)
    DOT             reduce using rule 54 (expr -> expr DIVIDE expr .)
    LBRACKET        reduce using rule 54 (expr -> expr DIVIDE expr .)
    PIPE            reduce using rule 54 (expr -> expr DIVIDE expr .)
    AMPERSAND       reduce using rule 54 (expr -> expr DIVIDE expr .)
    QUESTION        reduce using rule 54 (expr -> expr DIVIDE expr .)
    RPAREN          reduce using rule 54 (expr -> expr DIVIDE expr .)
    RBRACKET        reduce using rule 54 (expr -> expr DIVIDE expr .)
    COLON           reduce using rule 54 (expr -> expr DIVIDE expr .)

  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MOD             [ shift and go to state 83 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 117

    (55) expr -> expr MOD expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 55 (expr -> expr MOD expr .)
    PLUS            reduce using rule 55 (expr -> expr MOD expr .)
    MINUS           reduce using rule 55 (expr -> expr MOD expr .)
    TIMES           reduce using rule 55 (expr -> expr MOD expr .)
    DIVIDE          reduce using rule 55 (expr -> expr MOD expr .)
    MOD             reduce using rule 55 (expr -> expr MOD expr .)
    EQ              reduce using rule 55 (expr -> expr MOD expr .)
    NE              reduce using rule 55 (expr -> expr MOD expr .)
    LT              reduce using rule 55 (expr -> expr MOD expr .)
    LE              reduce using rule 55 (expr -> expr MOD expr .)
    GT              reduce using rule 55 (expr -> expr MOD expr .)
    GE              reduce using rule 55 (expr -> expr MOD expr .)
    AND             reduce using rule 55 (expr -> expr MOD expr .)
    OR              reduce using rule 55 (expr -> expr MOD expr .)
    DOT             reduce using rule 55 (expr -> expr MOD expr .)
    LBRACKET        reduce using rule 55 (expr -> expr MOD expr .)
    PIPE            reduce using rule 55 (expr -> expr MOD expr .)
    AMPERSAND       reduce using rule 55 (expr -> expr MOD expr .)
    QUESTION        reduce using rule 55 (expr -> expr MOD expr .)
    RPAREN          reduce using rule 55 (expr -> expr MOD expr .)
    RBRACKET        reduce using rule 55 (expr -> expr MOD expr .)
    COLON           reduce using rule 55 (expr -> expr MOD expr .)

  ! PLUS            [ shift and go to state 79 ]
  ! MINUS           [ shift and go to state 80 ]
  ! TIMES           [ shift and go to state 81 ]
  ! DIVIDE          [ shift and go to state 82 ]
  ! MOD             [ shift and go to state 83 ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 118

    (56) expr -> expr EQ expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 56 (expr -> expr EQ expr .)
    EQ              reduce using rule 56 (expr -> expr EQ expr .)
    NE              reduce using rule 56 (expr -> expr EQ expr .)
    AND             reduce using rule 56 (expr -> expr EQ expr .)
    OR              reduce using rule 56 (expr -> expr EQ expr .)
    DOT             reduce using rule 56 (expr -> expr EQ expr .)
    LBRACKET        reduce using rule 56 (expr -> expr EQ expr .)
    PIPE            reduce using rule 56 (expr -> expr EQ expr .)
    AMPERSAND       reduce using rule 56 (expr -> expr EQ expr .)
    QUESTION        reduce using rule 56 (expr -> expr EQ expr .)
    RPAREN          reduce using rule 56 (expr -> expr EQ expr .)
    RBRACKET        reduce using rule 56 (expr -> expr EQ expr .)
    COLON           reduce using rule 56 (expr -> expr EQ expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! MINUS           [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! TIMES           [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! DIVIDE          [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! MOD             [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! LT              [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! LE              [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! GT              [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! GE              [ reduce using rule 56 (expr -> expr EQ expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 119

    (57) expr -> expr NE expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 57 (expr -> expr NE expr .)
    EQ              reduce using rule 57 (expr -> expr NE expr .)
    NE              reduce using rule 57 (expr -> expr NE expr .)
    AND             reduce using rule 57 (expr -> expr NE expr .)
    OR              reduce using rule 57 (expr -> expr NE expr .)
    DOT             reduce using rule 57 (expr -> expr NE expr .)
    LBRACKET        reduce using rule 57 (expr -> expr NE expr .)
    PIPE            reduce using rule 57 (expr -> expr NE expr .)
    AMPERSAND       reduce using rule 57 (expr -> expr NE expr .)
    QUESTION        reduce using rule 57 (expr -> expr NE expr .)
    RPAREN          reduce using rule 57 (expr -> expr NE expr .)
    RBRACKET        reduce using rule 57 (expr -> expr NE expr .)
    COLON           reduce using rule 57 (expr -> expr NE expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! MINUS           [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! TIMES           [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! DIVIDE          [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! MOD             [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! LT              [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! LE              [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! GT              [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! GE              [ reduce using rule 57 (expr -> expr NE expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 120

    (58) expr -> expr LT expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 58 (expr -> expr LT expr .)
    EQ              reduce using rule 58 (expr -> expr LT expr .)
    NE              reduce using rule 58 (expr -> expr LT expr .)
    LT              reduce using rule 58 (expr -> expr LT expr .)
    LE              reduce using rule 58 (expr -> expr LT expr .)
    GT              reduce using rule 58 (expr -> expr LT expr .)
    GE              reduce using rule 58 (expr -> expr LT expr .)
    AND             reduce using rule 58 (expr -> expr LT expr .)
    OR              reduce using rule 58 (expr -> expr LT expr .)
    DOT             reduce using rule 58 (expr -> expr LT expr .)
    LBRACKET        reduce using rule 58 (expr -> expr LT expr .)
    PIPE            reduce using rule 58 (expr -> expr LT expr .)
    AMPERSAND       reduce using rule 58 (expr -> expr LT expr .)
    QUESTION        reduce using rule 58 (expr -> expr LT expr .)
    RPAREN          reduce using rule 58 (expr -> expr LT expr .)
    RBRACKET        reduce using rule 58 (expr -> expr LT expr .)
    COLON           reduce using rule 58 (expr -> expr LT expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! PLUS            [ reduce using rule 58 (expr -> expr LT expr .) ]
  ! MINUS           [ reduce using rule 58 (expr -> expr LT expr .) ]
  ! TIMES           [ reduce using rule 58 (expr -> expr LT expr .) ]
  ! DIVIDE          [ reduce using rule 58 (expr -> expr LT expr .) ]
  ! MOD             [ reduce using rule 58 (expr -> expr LT expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 121

    (59) expr -> expr LE expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 59 (expr -> expr LE expr .)
    EQ              reduce using rule 59 (expr -> expr LE expr .)
    NE              reduce using rule 59 (expr -> expr LE expr .)
    LT              reduce using rule 59 (expr -> expr LE expr .)
    LE              reduce using rule 59 (expr -> expr LE expr .)
    GT              reduce using rule 59 (expr -> expr LE expr .)
    GE              reduce using rule 59 (expr -> expr LE expr .)
    AND             reduce using rule 59 (expr -> expr LE expr .)
    OR              reduce using rule 59 (expr -> expr LE expr .)
    DOT             reduce using rule 59 (expr -> expr LE expr .)
    LBRACKET        reduce using rule 59 (expr -> expr LE expr .)
    PIPE            reduce using rule 59 (expr -> expr LE expr .)
    AMPERSAND       reduce using rule 59 (expr -> expr LE expr .)
    QUESTION        reduce using rule 59 (expr -> expr LE expr .)
    RPAREN          reduce using rule 59 (expr -> expr LE expr .)
    RBRACKET        reduce using rule 59 (expr -> expr LE expr .)
    COLON           reduce using rule 59 (expr -> expr LE expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! PLUS            [ reduce using rule 59 (expr -> expr LE expr .) ]
  ! MINUS           [ reduce using rule 59 (expr -> expr LE expr .) ]
  ! TIMES           [ reduce using rule 59 (expr -> expr LE expr .) ]
  ! DIVIDE          [ reduce using rule 59 (expr -> expr LE expr .) ]
  ! MOD             [ reduce using rule 59 (expr -> expr LE expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 122

    (60) expr -> expr GT expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 60 (expr -> expr GT expr .)
    EQ              reduce using rule 60 (expr -> expr GT expr .)
    NE              reduce using rule 60 (expr -> expr GT expr .)
    LT              reduce using rule 60 (expr -> expr GT expr .)
    LE              reduce using rule 60 (expr -> expr GT expr .)
    GT              reduce using rule 60 (expr -> expr GT expr .)
    GE              reduce using rule 60 (expr -> expr GT expr .)
    AND             reduce using rule 60 (expr -> expr GT expr .)
    OR              reduce using rule 60 (expr -> expr GT expr .)
    DOT             reduce using rule 60 (expr -> expr GT expr .)
    LBRACKET        reduce using rule 60 (expr -> expr GT expr .)
    PIPE            reduce using rule 60 (expr -> expr GT expr .)
    AMPERSAND       reduce using rule 60 (expr -> expr GT expr .)
    QUESTION        reduce using rule 60 (expr -> expr GT expr .)
    RPAREN          reduce using rule 60 (expr -> expr GT expr .)
    RBRACKET        reduce using rule 60 (expr -> expr GT expr .)
    COLON           reduce using rule 60 (expr -> expr GT expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! PLUS            [ reduce using rule 60 (expr -> expr GT expr .) ]
  ! MINUS           [ reduce using rule 60 (expr -> expr GT expr .) ]
  ! TIMES           [ reduce using rule 60 (expr -> expr GT expr .) ]
  ! DIVIDE          [ reduce using rule 60 (expr -> expr GT expr .) ]
  ! MOD             [ reduce using rule 60 (expr -> expr GT expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 123

    (61) expr -> expr GE expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 61 (expr -> expr GE expr .)
    EQ              reduce using rule 61 (expr -> expr GE expr .)
    NE              reduce using rule 61 (expr -> expr GE expr .)
    LT              reduce using rule 61 (expr -> expr GE expr .)
    LE              reduce using rule 61 (expr -> expr GE expr .)
    GT              reduce using rule 61 (expr -> expr GE expr .)
    GE              reduce using rule 61 (expr -> expr GE expr .)
    AND             reduce using rule 61 (expr -> expr GE expr .)
    OR              reduce using rule 61 (expr -> expr GE expr .)
    DOT             reduce using rule 61 (expr -> expr GE expr .)
    LBRACKET        reduce using rule 61 (expr -> expr GE expr .)
    PIPE            reduce using rule 61 (expr -> expr GE expr .)
    AMPERSAND       reduce using rule 61 (expr -> expr GE expr .)
    QUESTION        reduce using rule 61 (expr -> expr GE expr .)
    RPAREN          reduce using rule 61 (expr -> expr GE expr .)
    RBRACKET        reduce using rule 61 (expr -> expr GE expr .)
    COLON           reduce using rule 61 (expr -> expr GE expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83

  ! PLUS            [ reduce using rule 61 (expr -> expr GE expr .) ]
  ! MINUS           [ reduce using rule 61 (expr -> expr GE expr .) ]
  ! TIMES           [ reduce using rule 61 (expr -> expr GE expr .) ]
  ! DIVIDE          [ reduce using rule 61 (expr -> expr GE expr .) ]
  ! MOD             [ reduce using rule 61 (expr -> expr GE expr .) ]
  ! EQ              [ shift and go to state 84 ]
  ! NE              [ shift and go to state 85 ]
  ! LT              [ shift and go to state 86 ]
  ! LE              [ shift and go to state 87 ]
  ! GT              [ shift and go to state 88 ]
  ! GE              [ shift and go to state 89 ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 124

    (62) expr -> expr AND expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 62 (expr -> expr AND expr .)
    AND             reduce using rule 62 (expr -> expr AND expr .)
    OR              reduce using rule 62 (expr -> expr AND expr .)
    DOT             reduce using rule 62 (expr -> expr AND expr .)
    LBRACKET        reduce using rule 62 (expr -> expr AND expr .)
    PIPE            reduce using rule 62 (expr -> expr AND expr .)
    AMPERSAND       reduce using rule 62 (expr -> expr AND expr .)
    QUESTION        reduce using rule 62 (expr -> expr AND expr .)
    RPAREN          reduce using rule 62 (expr -> expr AND expr .)
    RBRACKET        reduce using rule 62 (expr -> expr AND expr .)
    COLON           reduce using rule 62 (expr -> expr AND expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89

  ! PLUS            [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! MINUS           [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! TIMES           [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! DIVIDE          [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! MOD             [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! EQ              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! NE              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! LT              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! LE              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! GT              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! GE              [ reduce using rule 62 (expr -> expr AND expr .) ]
  ! AND             [ shift and go to state 90 ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 125

    (63) expr -> expr OR expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       reduce using rule 63 (expr -> expr OR expr .)
    OR              reduce using rule 63 (expr -> expr OR expr .)
    DOT             reduce using rule 63 (expr -> expr OR expr .)
    LBRACKET        reduce using rule 63 (expr -> expr OR expr .)
    PIPE            reduce using rule 63 (expr -> expr OR expr .)
    AMPERSAND       reduce using rule 63 (expr -> expr OR expr .)
    QUESTION        reduce using rule 63 (expr -> expr OR expr .)
    RPAREN          reduce using rule 63 (expr -> expr OR expr .)
    RBRACKET        reduce using rule 63 (expr -> expr OR expr .)
    COLON           reduce using rule 63 (expr -> expr OR expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90

  ! PLUS            [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! MINUS           [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! TIMES           [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! DIVIDE          [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! MOD             [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! EQ              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! NE              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! LT              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! LE              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! GT              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! GE              [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! AND             [ reduce using rule 63 (expr -> expr OR expr .) ]
  ! OR              [ shift and go to state 91 ]
  ! DOT             [ shift and go to state 92 ]
  ! LBRACKET        [ shift and go to state 93 ]
  ! PIPE            [ shift and go to state 94 ]
  ! AMPERSAND       [ shift and go to state 95 ]
  ! QUESTION        [ shift and go to state 96 ]


state 126

    (75) expr -> expr DOT ID .

    SEMICOLON       reduce using rule 75 (expr -> expr DOT ID .)
    PLUS            reduce using rule 75 (expr -> expr DOT ID .)
    MINUS           reduce using rule 75 (expr -> expr DOT ID .)
    TIMES           reduce using rule 75 (expr -> expr DOT ID .)
    DIVIDE          reduce using rule 75 (expr -> expr DOT ID .)
    MOD             reduce using rule 75 (expr -> expr DOT ID .)
    EQ              reduce using rule 75 (expr -> expr DOT ID .)
    NE              reduce using rule 75 (expr -> expr DOT ID .)
    LT              reduce using rule 75 (expr -> expr DOT ID .)
    LE              reduce using rule 75 (expr -> expr DOT ID .)
    GT              reduce using rule 75 (expr -> expr DOT ID .)
    GE              reduce using rule 75 (expr -> expr DOT ID .)
    AND             reduce using rule 75 (expr -> expr DOT ID .)
    OR              reduce using rule 75 (expr -> expr DOT ID .)
    DOT             reduce using rule 75 (expr -> expr DOT ID .)
    LBRACKET        reduce using rule 75 (expr -> expr DOT ID .)
    PIPE            reduce using rule 75 (expr -> expr DOT ID .)
    AMPERSAND       reduce using rule 75 (expr -> expr DOT ID .)
    QUESTION        reduce using rule 75 (expr -> expr DOT ID .)
    RPAREN          reduce using rule 75 (expr -> expr DOT ID .)
    RBRACKET        reduce using rule 75 (expr -> expr DOT ID .)
    COLON           reduce using rule 75 (expr -> expr DOT ID .)


state 127

    (83) expr -> expr LBRACKET expr . RBRACKET
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    RBRACKET        shift and go to state 140
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 128

    (84) expr -> expr PIPE expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for AMPERSAND resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 84 (expr -> expr PIPE expr .)
    RPAREN          reduce using rule 84 (expr -> expr PIPE expr .)
    RBRACKET        reduce using rule 84 (expr -> expr PIPE expr .)
    COLON           reduce using rule 84 (expr -> expr PIPE expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96

  ! PLUS            [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! MINUS           [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! TIMES           [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! DIVIDE          [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! MOD             [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! EQ              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! NE              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! LT              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! LE              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! GT              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! GE              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! AND             [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! OR              [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! DOT             [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! LBRACKET        [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! PIPE            [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! AMPERSAND       [ reduce using rule 84 (expr -> expr PIPE expr .) ]
  ! QUESTION        [ reduce using rule 84 (expr -> expr PIPE expr .) ]


state 129

    (85) expr -> expr AMPERSAND expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for AMPERSAND resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 85 (expr -> expr AMPERSAND expr .)
    RPAREN          reduce using rule 85 (expr -> expr AMPERSAND expr .)
    RBRACKET        reduce using rule 85 (expr -> expr AMPERSAND expr .)
    COLON           reduce using rule 85 (expr -> expr AMPERSAND expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96

  ! PLUS            [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! MINUS           [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! TIMES           [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! DIVIDE          [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! MOD             [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! EQ              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! NE              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! LT              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! LE              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! GT              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! GE              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! AND             [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! OR              [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! DOT             [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! LBRACKET        [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! PIPE            [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! AMPERSAND       [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]
  ! QUESTION        [ reduce using rule 85 (expr -> expr AMPERSAND expr .) ]


state 130

    (86) expr -> expr QUESTION expr . COLON expr
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    COLON           shift and go to state 141
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 131

    (50) expr -> LPAREN type RPAREN . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    expr                           shift and go to state 142
    param                          shift and go to state 70

state 132

    (64) expr -> LPAREN expr RPAREN .

    SEMICOLON       reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    PLUS            reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    MINUS           reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    TIMES           reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    DIVIDE          reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    MOD             reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    EQ              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    NE              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    LT              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    LE              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    GT              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    GE              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    AND             reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    OR              reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    DOT             reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    LBRACKET        reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    PIPE            reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    AMPERSAND       reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    QUESTION        reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    RPAREN          reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    RBRACKET        reduce using rule 64 (expr -> LPAREN expr RPAREN .)
    COLON           reduce using rule 64 (expr -> LPAREN expr RPAREN .)


state 133

    (81) expr -> NEW type LPAREN . param_list RPAREN
    (20) param_list -> . param_list COMMA param
    (21) param_list -> . param
    (22) param_list -> . empty
    (23) param -> . type ID
    (93) empty -> .
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RPAREN          reduce using rule 93 (empty -> .)
    COMMA           reduce using rule 93 (empty -> .)
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 51
    param_list                     shift and go to state 143
    param                          shift and go to state 53
    empty                          shift and go to state 54

state 134

    (92) expr -> param ARROW expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for AMPERSAND resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 92 (expr -> param ARROW expr .)
    RPAREN          reduce using rule 92 (expr -> param ARROW expr .)
    RBRACKET        reduce using rule 92 (expr -> param ARROW expr .)
    COLON           reduce using rule 92 (expr -> param ARROW expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96

  ! PLUS            [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! MINUS           [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! TIMES           [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! DIVIDE          [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! MOD             [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! EQ              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! NE              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! LT              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! LE              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! GT              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! GE              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! AND             [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! OR              [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! DOT             [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! LBRACKET        [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! PIPE            [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! AMPERSAND       [ reduce using rule 92 (expr -> param ARROW expr .) ]
  ! QUESTION        [ reduce using rule 92 (expr -> param ARROW expr .) ]


state 135

    (19) var_decl -> type ID LBRACKET RBRACKET EQUALS expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 144
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 136

    (14) method_decl -> PRIVATE type ID LPAREN param_list RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 145


state 137

    (13) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 146
    empty                          shift and go to state 139

state 138

    (15) method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 149
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 147
    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155

state 139

    (34) stmt_list -> empty .

    RBRACE          reduce using rule 34 (stmt_list -> empty .)
    ID              reduce using rule 34 (stmt_list -> empty .)
    INCREMENT       reduce using rule 34 (stmt_list -> empty .)
    DECREMENT       reduce using rule 34 (stmt_list -> empty .)
    WHILE           reduce using rule 34 (stmt_list -> empty .)
    DO              reduce using rule 34 (stmt_list -> empty .)
    BREAK           reduce using rule 34 (stmt_list -> empty .)
    CONTINUE        reduce using rule 34 (stmt_list -> empty .)
    IF              reduce using rule 34 (stmt_list -> empty .)
    RETURN          reduce using rule 34 (stmt_list -> empty .)
    FOR             reduce using rule 34 (stmt_list -> empty .)
    INT             reduce using rule 34 (stmt_list -> empty .)
    FLOAT           reduce using rule 34 (stmt_list -> empty .)
    DOUBLE          reduce using rule 34 (stmt_list -> empty .)
    STRINGTYPE      reduce using rule 34 (stmt_list -> empty .)
    BOOL            reduce using rule 34 (stmt_list -> empty .)
    CHAR            reduce using rule 34 (stmt_list -> empty .)
    VOID            reduce using rule 34 (stmt_list -> empty .)
    VAR             reduce using rule 34 (stmt_list -> empty .)
    LIST            reduce using rule 34 (stmt_list -> empty .)


state 140

    (83) expr -> expr LBRACKET expr RBRACKET .

    SEMICOLON       reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    PLUS            reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    MINUS           reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    TIMES           reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    DIVIDE          reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    MOD             reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    EQ              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    NE              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    LT              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    LE              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    GT              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    GE              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    AND             reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    OR              reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    DOT             reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    LBRACKET        reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    PIPE            reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    AMPERSAND       reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    QUESTION        reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    RPAREN          reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    RBRACKET        reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)
    COLON           reduce using rule 83 (expr -> expr LBRACKET expr RBRACKET .)


state 141

    (86) expr -> expr QUESTION expr COLON . expr
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 165
    type                           shift and go to state 51
    param                          shift and go to state 70

state 142

    (50) expr -> LPAREN type RPAREN expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for AMPERSAND resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 50 (expr -> LPAREN type RPAREN expr .)
    RPAREN          reduce using rule 50 (expr -> LPAREN type RPAREN expr .)
    RBRACKET        reduce using rule 50 (expr -> LPAREN type RPAREN expr .)
    COLON           reduce using rule 50 (expr -> LPAREN type RPAREN expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96

  ! PLUS            [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! MINUS           [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! TIMES           [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! DIVIDE          [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! MOD             [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! EQ              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! NE              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! LT              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! LE              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! GT              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! GE              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! AND             [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! OR              [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! DOT             [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! LBRACKET        [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! PIPE            [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! AMPERSAND       [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]
  ! QUESTION        [ reduce using rule 50 (expr -> LPAREN type RPAREN expr .) ]


state 143

    (81) expr -> NEW type LPAREN param_list . RPAREN
    (20) param_list -> param_list . COMMA param

    RPAREN          shift and go to state 166
    COMMA           shift and go to state 77


state 144

    (19) var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .

    RBRACE          reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    PUBLIC          reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    PRIVATE         reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    INT             reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    VOID            reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    VAR             reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    LIST            reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    ID              reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    INCREMENT       reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    DECREMENT       reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    DO              reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    BREAK           reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    CONTINUE        reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    IF              reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)
    FOR             reduce using rule 19 (var_decl -> type ID LBRACKET RBRACKET EQUALS expr SEMICOLON .)


state 145

    (14) method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 167
    empty                          shift and go to state 139

state 146

    (13) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 168
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 147
    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155

state 147

    (16) var_decl -> type . ID EQUALS expr SEMICOLON
    (17) var_decl -> type . ID SEMICOLON
    (18) var_decl -> type . ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> type . ID LBRACKET RBRACKET EQUALS expr SEMICOLON

    ID              shift and go to state 169


state 148

    (46) stmt -> ID . INCREMENT SEMICOLON
    (47) stmt -> ID . DECREMENT SEMICOLON
    (40) assign_stmt -> ID . EQUALS expr SEMICOLON
    (87) assign_stmt -> ID . PLUSEQ expr SEMICOLON
    (88) assign_stmt -> ID . MINUSEQ expr SEMICOLON
    (89) assign_stmt -> ID . TIMESEQ expr SEMICOLON
    (90) assign_stmt -> ID . DIVEQ expr SEMICOLON
    (91) assign_stmt -> ID . MODEQ expr SEMICOLON

    INCREMENT       shift and go to state 170
    DECREMENT       shift and go to state 171
    EQUALS          shift and go to state 172
    PLUSEQ          shift and go to state 173
    MINUSEQ         shift and go to state 174
    TIMESEQ         shift and go to state 175
    DIVEQ           shift and go to state 176
    MODEQ           shift and go to state 177


state 149

    (15) method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PUBLIC          reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PRIVATE         reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 15 (method_decl -> type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)


state 150

    (33) stmt_list -> stmt_list stmt .

    RBRACE          reduce using rule 33 (stmt_list -> stmt_list stmt .)
    ID              reduce using rule 33 (stmt_list -> stmt_list stmt .)
    INCREMENT       reduce using rule 33 (stmt_list -> stmt_list stmt .)
    DECREMENT       reduce using rule 33 (stmt_list -> stmt_list stmt .)
    WHILE           reduce using rule 33 (stmt_list -> stmt_list stmt .)
    DO              reduce using rule 33 (stmt_list -> stmt_list stmt .)
    BREAK           reduce using rule 33 (stmt_list -> stmt_list stmt .)
    CONTINUE        reduce using rule 33 (stmt_list -> stmt_list stmt .)
    IF              reduce using rule 33 (stmt_list -> stmt_list stmt .)
    RETURN          reduce using rule 33 (stmt_list -> stmt_list stmt .)
    FOR             reduce using rule 33 (stmt_list -> stmt_list stmt .)
    INT             reduce using rule 33 (stmt_list -> stmt_list stmt .)
    FLOAT           reduce using rule 33 (stmt_list -> stmt_list stmt .)
    DOUBLE          reduce using rule 33 (stmt_list -> stmt_list stmt .)
    STRINGTYPE      reduce using rule 33 (stmt_list -> stmt_list stmt .)
    BOOL            reduce using rule 33 (stmt_list -> stmt_list stmt .)
    CHAR            reduce using rule 33 (stmt_list -> stmt_list stmt .)
    VOID            reduce using rule 33 (stmt_list -> stmt_list stmt .)
    VAR             reduce using rule 33 (stmt_list -> stmt_list stmt .)
    LIST            reduce using rule 33 (stmt_list -> stmt_list stmt .)


state 151

    (35) stmt -> var_decl .

    RBRACE          reduce using rule 35 (stmt -> var_decl .)
    ID              reduce using rule 35 (stmt -> var_decl .)
    INCREMENT       reduce using rule 35 (stmt -> var_decl .)
    DECREMENT       reduce using rule 35 (stmt -> var_decl .)
    WHILE           reduce using rule 35 (stmt -> var_decl .)
    DO              reduce using rule 35 (stmt -> var_decl .)
    BREAK           reduce using rule 35 (stmt -> var_decl .)
    CONTINUE        reduce using rule 35 (stmt -> var_decl .)
    IF              reduce using rule 35 (stmt -> var_decl .)
    RETURN          reduce using rule 35 (stmt -> var_decl .)
    FOR             reduce using rule 35 (stmt -> var_decl .)
    INT             reduce using rule 35 (stmt -> var_decl .)
    FLOAT           reduce using rule 35 (stmt -> var_decl .)
    DOUBLE          reduce using rule 35 (stmt -> var_decl .)
    STRINGTYPE      reduce using rule 35 (stmt -> var_decl .)
    BOOL            reduce using rule 35 (stmt -> var_decl .)
    CHAR            reduce using rule 35 (stmt -> var_decl .)
    VOID            reduce using rule 35 (stmt -> var_decl .)
    VAR             reduce using rule 35 (stmt -> var_decl .)
    LIST            reduce using rule 35 (stmt -> var_decl .)


state 152

    (36) stmt -> assign_stmt .

    RBRACE          reduce using rule 36 (stmt -> assign_stmt .)
    ID              reduce using rule 36 (stmt -> assign_stmt .)
    INCREMENT       reduce using rule 36 (stmt -> assign_stmt .)
    DECREMENT       reduce using rule 36 (stmt -> assign_stmt .)
    WHILE           reduce using rule 36 (stmt -> assign_stmt .)
    DO              reduce using rule 36 (stmt -> assign_stmt .)
    BREAK           reduce using rule 36 (stmt -> assign_stmt .)
    CONTINUE        reduce using rule 36 (stmt -> assign_stmt .)
    IF              reduce using rule 36 (stmt -> assign_stmt .)
    RETURN          reduce using rule 36 (stmt -> assign_stmt .)
    FOR             reduce using rule 36 (stmt -> assign_stmt .)
    INT             reduce using rule 36 (stmt -> assign_stmt .)
    FLOAT           reduce using rule 36 (stmt -> assign_stmt .)
    DOUBLE          reduce using rule 36 (stmt -> assign_stmt .)
    STRINGTYPE      reduce using rule 36 (stmt -> assign_stmt .)
    BOOL            reduce using rule 36 (stmt -> assign_stmt .)
    CHAR            reduce using rule 36 (stmt -> assign_stmt .)
    VOID            reduce using rule 36 (stmt -> assign_stmt .)
    VAR             reduce using rule 36 (stmt -> assign_stmt .)
    LIST            reduce using rule 36 (stmt -> assign_stmt .)


state 153

    (37) stmt -> if_stmt .

    RBRACE          reduce using rule 37 (stmt -> if_stmt .)
    ID              reduce using rule 37 (stmt -> if_stmt .)
    INCREMENT       reduce using rule 37 (stmt -> if_stmt .)
    DECREMENT       reduce using rule 37 (stmt -> if_stmt .)
    WHILE           reduce using rule 37 (stmt -> if_stmt .)
    DO              reduce using rule 37 (stmt -> if_stmt .)
    BREAK           reduce using rule 37 (stmt -> if_stmt .)
    CONTINUE        reduce using rule 37 (stmt -> if_stmt .)
    IF              reduce using rule 37 (stmt -> if_stmt .)
    RETURN          reduce using rule 37 (stmt -> if_stmt .)
    FOR             reduce using rule 37 (stmt -> if_stmt .)
    INT             reduce using rule 37 (stmt -> if_stmt .)
    FLOAT           reduce using rule 37 (stmt -> if_stmt .)
    DOUBLE          reduce using rule 37 (stmt -> if_stmt .)
    STRINGTYPE      reduce using rule 37 (stmt -> if_stmt .)
    BOOL            reduce using rule 37 (stmt -> if_stmt .)
    CHAR            reduce using rule 37 (stmt -> if_stmt .)
    VOID            reduce using rule 37 (stmt -> if_stmt .)
    VAR             reduce using rule 37 (stmt -> if_stmt .)
    LIST            reduce using rule 37 (stmt -> if_stmt .)


state 154

    (38) stmt -> return_stmt .

    RBRACE          reduce using rule 38 (stmt -> return_stmt .)
    ID              reduce using rule 38 (stmt -> return_stmt .)
    INCREMENT       reduce using rule 38 (stmt -> return_stmt .)
    DECREMENT       reduce using rule 38 (stmt -> return_stmt .)
    WHILE           reduce using rule 38 (stmt -> return_stmt .)
    DO              reduce using rule 38 (stmt -> return_stmt .)
    BREAK           reduce using rule 38 (stmt -> return_stmt .)
    CONTINUE        reduce using rule 38 (stmt -> return_stmt .)
    IF              reduce using rule 38 (stmt -> return_stmt .)
    RETURN          reduce using rule 38 (stmt -> return_stmt .)
    FOR             reduce using rule 38 (stmt -> return_stmt .)
    INT             reduce using rule 38 (stmt -> return_stmt .)
    FLOAT           reduce using rule 38 (stmt -> return_stmt .)
    DOUBLE          reduce using rule 38 (stmt -> return_stmt .)
    STRINGTYPE      reduce using rule 38 (stmt -> return_stmt .)
    BOOL            reduce using rule 38 (stmt -> return_stmt .)
    CHAR            reduce using rule 38 (stmt -> return_stmt .)
    VOID            reduce using rule 38 (stmt -> return_stmt .)
    VAR             reduce using rule 38 (stmt -> return_stmt .)
    LIST            reduce using rule 38 (stmt -> return_stmt .)


state 155

    (39) stmt -> for_stmt .

    RBRACE          reduce using rule 39 (stmt -> for_stmt .)
    ID              reduce using rule 39 (stmt -> for_stmt .)
    INCREMENT       reduce using rule 39 (stmt -> for_stmt .)
    DECREMENT       reduce using rule 39 (stmt -> for_stmt .)
    WHILE           reduce using rule 39 (stmt -> for_stmt .)
    DO              reduce using rule 39 (stmt -> for_stmt .)
    BREAK           reduce using rule 39 (stmt -> for_stmt .)
    CONTINUE        reduce using rule 39 (stmt -> for_stmt .)
    IF              reduce using rule 39 (stmt -> for_stmt .)
    RETURN          reduce using rule 39 (stmt -> for_stmt .)
    FOR             reduce using rule 39 (stmt -> for_stmt .)
    INT             reduce using rule 39 (stmt -> for_stmt .)
    FLOAT           reduce using rule 39 (stmt -> for_stmt .)
    DOUBLE          reduce using rule 39 (stmt -> for_stmt .)
    STRINGTYPE      reduce using rule 39 (stmt -> for_stmt .)
    BOOL            reduce using rule 39 (stmt -> for_stmt .)
    CHAR            reduce using rule 39 (stmt -> for_stmt .)
    VOID            reduce using rule 39 (stmt -> for_stmt .)
    VAR             reduce using rule 39 (stmt -> for_stmt .)
    LIST            reduce using rule 39 (stmt -> for_stmt .)


state 156

    (48) stmt -> INCREMENT . ID SEMICOLON

    ID              shift and go to state 178


state 157

    (49) stmt -> DECREMENT . ID SEMICOLON

    ID              shift and go to state 179


state 158

    (76) stmt -> WHILE . LPAREN expr RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 180


state 159

    (77) stmt -> DO . LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON

    LBRACE          shift and go to state 181


state 160

    (78) stmt -> BREAK . SEMICOLON

    SEMICOLON       shift and go to state 182


state 161

    (79) stmt -> CONTINUE . SEMICOLON

    SEMICOLON       shift and go to state 183


state 162

    (41) if_stmt -> IF . LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part

    LPAREN          shift and go to state 184


state 163

    (44) return_stmt -> RETURN . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 185
    type                           shift and go to state 51
    param                          shift and go to state 70

state 164

    (45) for_stmt -> FOR . LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE

    LPAREN          shift and go to state 186


state 165

    (86) expr -> expr QUESTION expr COLON expr .
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NE resolved as shift
  ! shift/reduce conflict for LT resolved as shift
  ! shift/reduce conflict for LE resolved as shift
  ! shift/reduce conflict for GT resolved as shift
  ! shift/reduce conflict for GE resolved as shift
  ! shift/reduce conflict for AND resolved as shift
  ! shift/reduce conflict for OR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for LBRACKET resolved as shift
  ! shift/reduce conflict for PIPE resolved as shift
  ! shift/reduce conflict for AMPERSAND resolved as shift
  ! shift/reduce conflict for QUESTION resolved as shift
    SEMICOLON       reduce using rule 86 (expr -> expr QUESTION expr COLON expr .)
    RPAREN          reduce using rule 86 (expr -> expr QUESTION expr COLON expr .)
    RBRACKET        reduce using rule 86 (expr -> expr QUESTION expr COLON expr .)
    COLON           reduce using rule 86 (expr -> expr QUESTION expr COLON expr .)
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96

  ! PLUS            [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! MINUS           [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! TIMES           [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! DIVIDE          [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! MOD             [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! EQ              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! NE              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! LT              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! LE              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! GT              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! GE              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! AND             [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! OR              [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! DOT             [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! LBRACKET        [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! PIPE            [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! AMPERSAND       [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]
  ! QUESTION        [ reduce using rule 86 (expr -> expr QUESTION expr COLON expr .) ]


state 166

    (81) expr -> NEW type LPAREN param_list RPAREN .

    SEMICOLON       reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    PLUS            reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    MINUS           reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    TIMES           reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    DIVIDE          reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    MOD             reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    EQ              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    NE              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    LT              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    LE              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    GT              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    GE              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    AND             reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    OR              reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    DOT             reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    LBRACKET        reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    PIPE            reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    AMPERSAND       reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    QUESTION        reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    RPAREN          reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    RBRACKET        reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)
    COLON           reduce using rule 81 (expr -> NEW type LPAREN param_list RPAREN .)


state 167

    (14) method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 187
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    type                           shift and go to state 147
    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155

state 168

    (13) method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PUBLIC          reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PRIVATE         reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 13 (method_decl -> PUBLIC type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)


state 169

    (16) var_decl -> type ID . EQUALS expr SEMICOLON
    (17) var_decl -> type ID . SEMICOLON
    (18) var_decl -> type ID . LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> type ID . LBRACKET RBRACKET EQUALS expr SEMICOLON

    EQUALS          shift and go to state 45
    SEMICOLON       shift and go to state 46
    LBRACKET        shift and go to state 47


state 170

    (46) stmt -> ID INCREMENT . SEMICOLON

    SEMICOLON       shift and go to state 188


state 171

    (47) stmt -> ID DECREMENT . SEMICOLON

    SEMICOLON       shift and go to state 189


state 172

    (40) assign_stmt -> ID EQUALS . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 190
    type                           shift and go to state 51
    param                          shift and go to state 70

state 173

    (87) assign_stmt -> ID PLUSEQ . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 191
    type                           shift and go to state 51
    param                          shift and go to state 70

state 174

    (88) assign_stmt -> ID MINUSEQ . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 192
    type                           shift and go to state 51
    param                          shift and go to state 70

state 175

    (89) assign_stmt -> ID TIMESEQ . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 193
    type                           shift and go to state 51
    param                          shift and go to state 70

state 176

    (90) assign_stmt -> ID DIVEQ . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 194
    type                           shift and go to state 51
    param                          shift and go to state 70

state 177

    (91) assign_stmt -> ID MODEQ . expr SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 195
    type                           shift and go to state 51
    param                          shift and go to state 70

state 178

    (48) stmt -> INCREMENT ID . SEMICOLON

    SEMICOLON       shift and go to state 196


state 179

    (49) stmt -> DECREMENT ID . SEMICOLON

    SEMICOLON       shift and go to state 197


state 180

    (76) stmt -> WHILE LPAREN . expr RPAREN LBRACE stmt_list RBRACE
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 198
    type                           shift and go to state 51
    param                          shift and go to state 70

state 181

    (77) stmt -> DO LBRACE . stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 199
    empty                          shift and go to state 139

state 182

    (78) stmt -> BREAK SEMICOLON .

    RBRACE          reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    ID              reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    INCREMENT       reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    DECREMENT       reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    WHILE           reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    DO              reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    BREAK           reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    CONTINUE        reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    IF              reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    RETURN          reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    FOR             reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    INT             reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    FLOAT           reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    DOUBLE          reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    STRINGTYPE      reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    BOOL            reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    CHAR            reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    VOID            reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    VAR             reduce using rule 78 (stmt -> BREAK SEMICOLON .)
    LIST            reduce using rule 78 (stmt -> BREAK SEMICOLON .)


state 183

    (79) stmt -> CONTINUE SEMICOLON .

    RBRACE          reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    ID              reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    INCREMENT       reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    DECREMENT       reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    WHILE           reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    DO              reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    BREAK           reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    CONTINUE        reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    IF              reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    RETURN          reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    FOR             reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    INT             reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    FLOAT           reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    DOUBLE          reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    STRINGTYPE      reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    BOOL            reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    CHAR            reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    VOID            reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    VAR             reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)
    LIST            reduce using rule 79 (stmt -> CONTINUE SEMICOLON .)


state 184

    (41) if_stmt -> IF LPAREN . expr RPAREN LBRACE stmt_list RBRACE else_part
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 200
    type                           shift and go to state 51
    param                          shift and go to state 70

state 185

    (44) return_stmt -> RETURN expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 201
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 186

    (45) for_stmt -> FOR LPAREN . assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON

    ID              shift and go to state 203

    assign_stmt                    shift and go to state 202

state 187

    (14) method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PUBLIC          reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    PRIVATE         reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 14 (method_decl -> PRIVATE type ID LPAREN param_list RPAREN LBRACE stmt_list RBRACE .)


state 188

    (46) stmt -> ID INCREMENT SEMICOLON .

    RBRACE          reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    ID              reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    INCREMENT       reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    DECREMENT       reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    WHILE           reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    DO              reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    BREAK           reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    CONTINUE        reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    IF              reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    RETURN          reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    FOR             reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    INT             reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    FLOAT           reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    DOUBLE          reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    STRINGTYPE      reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    BOOL            reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    CHAR            reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    VOID            reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    VAR             reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)
    LIST            reduce using rule 46 (stmt -> ID INCREMENT SEMICOLON .)


state 189

    (47) stmt -> ID DECREMENT SEMICOLON .

    RBRACE          reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    ID              reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    INCREMENT       reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    DECREMENT       reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    WHILE           reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    DO              reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    BREAK           reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    CONTINUE        reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    IF              reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    RETURN          reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    FOR             reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    INT             reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    FLOAT           reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    DOUBLE          reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    STRINGTYPE      reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    BOOL            reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    CHAR            reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    VOID            reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    VAR             reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)
    LIST            reduce using rule 47 (stmt -> ID DECREMENT SEMICOLON .)


state 190

    (40) assign_stmt -> ID EQUALS expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 204
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 191

    (87) assign_stmt -> ID PLUSEQ expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 205
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 192

    (88) assign_stmt -> ID MINUSEQ expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 206
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 193

    (89) assign_stmt -> ID TIMESEQ expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 207
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 194

    (90) assign_stmt -> ID DIVEQ expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 208
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 195

    (91) assign_stmt -> ID MODEQ expr . SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 209
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 196

    (48) stmt -> INCREMENT ID SEMICOLON .

    RBRACE          reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    ID              reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    INCREMENT       reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    DECREMENT       reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    WHILE           reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    DO              reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    BREAK           reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    CONTINUE        reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    IF              reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    RETURN          reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    FOR             reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    INT             reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    FLOAT           reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    DOUBLE          reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    STRINGTYPE      reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    BOOL            reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    CHAR            reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    VOID            reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    VAR             reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)
    LIST            reduce using rule 48 (stmt -> INCREMENT ID SEMICOLON .)


state 197

    (49) stmt -> DECREMENT ID SEMICOLON .

    RBRACE          reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    ID              reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    INCREMENT       reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    DECREMENT       reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    WHILE           reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    DO              reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    BREAK           reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    CONTINUE        reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    IF              reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    RETURN          reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    FOR             reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    INT             reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    FLOAT           reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    DOUBLE          reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    STRINGTYPE      reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    BOOL            reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    CHAR            reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    VOID            reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    VAR             reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)
    LIST            reduce using rule 49 (stmt -> DECREMENT ID SEMICOLON .)


state 198

    (76) stmt -> WHILE LPAREN expr . RPAREN LBRACE stmt_list RBRACE
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    RPAREN          shift and go to state 210
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 199

    (77) stmt -> DO LBRACE stmt_list . RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 211
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155
    type                           shift and go to state 147

state 200

    (41) if_stmt -> IF LPAREN expr . RPAREN LBRACE stmt_list RBRACE else_part
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    RPAREN          shift and go to state 212
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 201

    (44) return_stmt -> RETURN expr SEMICOLON .

    RBRACE          reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    ID              reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    INCREMENT       reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    DECREMENT       reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    WHILE           reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    DO              reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    BREAK           reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    CONTINUE        reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    IF              reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    RETURN          reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    FOR             reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    INT             reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    FLOAT           reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    DOUBLE          reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    STRINGTYPE      reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    BOOL            reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    CHAR            reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    VOID            reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    VAR             reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)
    LIST            reduce using rule 44 (return_stmt -> RETURN expr SEMICOLON .)


state 202

    (45) for_stmt -> FOR LPAREN assign_stmt . expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 213
    type                           shift and go to state 51
    param                          shift and go to state 70

state 203

    (40) assign_stmt -> ID . EQUALS expr SEMICOLON
    (87) assign_stmt -> ID . PLUSEQ expr SEMICOLON
    (88) assign_stmt -> ID . MINUSEQ expr SEMICOLON
    (89) assign_stmt -> ID . TIMESEQ expr SEMICOLON
    (90) assign_stmt -> ID . DIVEQ expr SEMICOLON
    (91) assign_stmt -> ID . MODEQ expr SEMICOLON

    EQUALS          shift and go to state 172
    PLUSEQ          shift and go to state 173
    MINUSEQ         shift and go to state 174
    TIMESEQ         shift and go to state 175
    DIVEQ           shift and go to state 176
    MODEQ           shift and go to state 177


state 204

    (40) assign_stmt -> ID EQUALS expr SEMICOLON .

    RBRACE          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    ID              reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    INCREMENT       reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    DECREMENT       reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    WHILE           reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    DO              reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    BREAK           reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    CONTINUE        reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    IF              reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    RETURN          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FOR             reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    INT             reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FLOAT           reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    DOUBLE          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    STRINGTYPE      reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    BOOL            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    CHAR            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    VOID            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    VAR             reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    LIST            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    LPAREN          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    NOT             reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    MINUS           reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    STRING          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    TRUE            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    FALSE           reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    NULL            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    NEW             reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    THIS            reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)
    RPAREN          reduce using rule 40 (assign_stmt -> ID EQUALS expr SEMICOLON .)


state 205

    (87) assign_stmt -> ID PLUSEQ expr SEMICOLON .

    RBRACE          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    ID              reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    INCREMENT       reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    DECREMENT       reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    WHILE           reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    DO              reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    BREAK           reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    CONTINUE        reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    IF              reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    RETURN          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    FOR             reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    INT             reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    FLOAT           reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    DOUBLE          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    STRINGTYPE      reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    BOOL            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    CHAR            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    VOID            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    VAR             reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    LIST            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    LPAREN          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    NOT             reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    MINUS           reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    STRING          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    TRUE            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    FALSE           reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    NULL            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    NEW             reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    THIS            reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)
    RPAREN          reduce using rule 87 (assign_stmt -> ID PLUSEQ expr SEMICOLON .)


state 206

    (88) assign_stmt -> ID MINUSEQ expr SEMICOLON .

    RBRACE          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    ID              reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    INCREMENT       reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    DECREMENT       reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    WHILE           reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    DO              reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    BREAK           reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    CONTINUE        reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    IF              reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    RETURN          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    FOR             reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    INT             reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    FLOAT           reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    DOUBLE          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    STRINGTYPE      reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    BOOL            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    CHAR            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    VOID            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    VAR             reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    LIST            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    LPAREN          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    NOT             reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    MINUS           reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    STRING          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    TRUE            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    FALSE           reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    NULL            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    NEW             reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    THIS            reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)
    RPAREN          reduce using rule 88 (assign_stmt -> ID MINUSEQ expr SEMICOLON .)


state 207

    (89) assign_stmt -> ID TIMESEQ expr SEMICOLON .

    RBRACE          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    ID              reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    INCREMENT       reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    DECREMENT       reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    WHILE           reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    DO              reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    BREAK           reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    CONTINUE        reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    IF              reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    RETURN          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    FOR             reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    INT             reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    FLOAT           reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    DOUBLE          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    STRINGTYPE      reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    BOOL            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    CHAR            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    VOID            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    VAR             reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    LIST            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    LPAREN          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    NOT             reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    MINUS           reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    STRING          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    TRUE            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    FALSE           reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    NULL            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    NEW             reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    THIS            reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)
    RPAREN          reduce using rule 89 (assign_stmt -> ID TIMESEQ expr SEMICOLON .)


state 208

    (90) assign_stmt -> ID DIVEQ expr SEMICOLON .

    RBRACE          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    ID              reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    INCREMENT       reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    DECREMENT       reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    WHILE           reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    DO              reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    BREAK           reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    CONTINUE        reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    IF              reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    RETURN          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    FOR             reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    INT             reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    FLOAT           reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    DOUBLE          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    STRINGTYPE      reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    BOOL            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    CHAR            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    VOID            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    VAR             reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    LIST            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    LPAREN          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    NOT             reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    MINUS           reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    STRING          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    TRUE            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    FALSE           reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    NULL            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    NEW             reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    THIS            reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)
    RPAREN          reduce using rule 90 (assign_stmt -> ID DIVEQ expr SEMICOLON .)


state 209

    (91) assign_stmt -> ID MODEQ expr SEMICOLON .

    RBRACE          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    ID              reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    INCREMENT       reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    DECREMENT       reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    WHILE           reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    DO              reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    BREAK           reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    CONTINUE        reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    IF              reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    RETURN          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    FOR             reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    INT             reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    FLOAT           reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    DOUBLE          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    STRINGTYPE      reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    BOOL            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    CHAR            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    VOID            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    VAR             reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    LIST            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    LPAREN          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    NOT             reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    MINUS           reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    STRING          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    TRUE            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    FALSE           reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    NULL            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    NEW             reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    THIS            reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)
    RPAREN          reduce using rule 91 (assign_stmt -> ID MODEQ expr SEMICOLON .)


state 210

    (76) stmt -> WHILE LPAREN expr RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 214


state 211

    (77) stmt -> DO LBRACE stmt_list RBRACE . WHILE LPAREN expr RPAREN SEMICOLON

    WHILE           shift and go to state 215


state 212

    (41) if_stmt -> IF LPAREN expr RPAREN . LBRACE stmt_list RBRACE else_part

    LBRACE          shift and go to state 216


state 213

    (45) for_stmt -> FOR LPAREN assign_stmt expr . SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    SEMICOLON       shift and go to state 217
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 214

    (76) stmt -> WHILE LPAREN expr RPAREN LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 218
    empty                          shift and go to state 139

state 215

    (77) stmt -> DO LBRACE stmt_list RBRACE WHILE . LPAREN expr RPAREN SEMICOLON

    LPAREN          shift and go to state 219


state 216

    (41) if_stmt -> IF LPAREN expr RPAREN LBRACE . stmt_list RBRACE else_part
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 220
    empty                          shift and go to state 139

state 217

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON . assign_stmt RPAREN LBRACE stmt_list RBRACE
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON

    ID              shift and go to state 203

    assign_stmt                    shift and go to state 221

state 218

    (76) stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 222
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155
    type                           shift and go to state 147

state 219

    (77) stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN . expr RPAREN SEMICOLON
    (50) expr -> . LPAREN type RPAREN expr
    (51) expr -> . expr PLUS expr
    (52) expr -> . expr MINUS expr
    (53) expr -> . expr TIMES expr
    (54) expr -> . expr DIVIDE expr
    (55) expr -> . expr MOD expr
    (56) expr -> . expr EQ expr
    (57) expr -> . expr NE expr
    (58) expr -> . expr LT expr
    (59) expr -> . expr LE expr
    (60) expr -> . expr GT expr
    (61) expr -> . expr GE expr
    (62) expr -> . expr AND expr
    (63) expr -> . expr OR expr
    (64) expr -> . LPAREN expr RPAREN
    (65) expr -> . NOT expr
    (66) expr -> . MINUS expr
    (67) expr -> . ID
    (68) expr -> . INT
    (69) expr -> . FLOAT
    (70) expr -> . DOUBLE
    (71) expr -> . STRING
    (72) expr -> . TRUE
    (73) expr -> . FALSE
    (74) expr -> . CHAR
    (75) expr -> . expr DOT ID
    (80) expr -> . NULL
    (81) expr -> . NEW type LPAREN param_list RPAREN
    (82) expr -> . THIS
    (83) expr -> . expr LBRACKET expr RBRACKET
    (84) expr -> . expr PIPE expr
    (85) expr -> . expr AMPERSAND expr
    (86) expr -> . expr QUESTION expr COLON expr
    (92) expr -> . param ARROW expr
    (23) param -> . type ID
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    LPAREN          shift and go to state 57
    NOT             shift and go to state 59
    MINUS           shift and go to state 58
    ID              shift and go to state 55
    INT             shift and go to state 60
    FLOAT           shift and go to state 61
    DOUBLE          shift and go to state 62
    STRING          shift and go to state 63
    TRUE            shift and go to state 64
    FALSE           shift and go to state 65
    CHAR            shift and go to state 66
    NULL            shift and go to state 67
    NEW             shift and go to state 68
    THIS            shift and go to state 69
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    expr                           shift and go to state 223
    type                           shift and go to state 51
    param                          shift and go to state 70

state 220

    (41) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list . RBRACE else_part
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 224
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155
    type                           shift and go to state 147

state 221

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt . RPAREN LBRACE stmt_list RBRACE

    RPAREN          shift and go to state 225


state 222

    (76) stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    ID              reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    DECREMENT       reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    DO              reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 76 (stmt -> WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE .)


state 223

    (77) stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr . RPAREN SEMICOLON
    (51) expr -> expr . PLUS expr
    (52) expr -> expr . MINUS expr
    (53) expr -> expr . TIMES expr
    (54) expr -> expr . DIVIDE expr
    (55) expr -> expr . MOD expr
    (56) expr -> expr . EQ expr
    (57) expr -> expr . NE expr
    (58) expr -> expr . LT expr
    (59) expr -> expr . LE expr
    (60) expr -> expr . GT expr
    (61) expr -> expr . GE expr
    (62) expr -> expr . AND expr
    (63) expr -> expr . OR expr
    (75) expr -> expr . DOT ID
    (83) expr -> expr . LBRACKET expr RBRACKET
    (84) expr -> expr . PIPE expr
    (85) expr -> expr . AMPERSAND expr
    (86) expr -> expr . QUESTION expr COLON expr

    RPAREN          shift and go to state 226
    PLUS            shift and go to state 79
    MINUS           shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MOD             shift and go to state 83
    EQ              shift and go to state 84
    NE              shift and go to state 85
    LT              shift and go to state 86
    LE              shift and go to state 87
    GT              shift and go to state 88
    GE              shift and go to state 89
    AND             shift and go to state 90
    OR              shift and go to state 91
    DOT             shift and go to state 92
    LBRACKET        shift and go to state 93
    PIPE            shift and go to state 94
    AMPERSAND       shift and go to state 95
    QUESTION        shift and go to state 96


state 224

    (41) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE . else_part
    (42) else_part -> . ELSE LBRACE stmt_list RBRACE
    (43) else_part -> . empty
    (93) empty -> .

    ELSE            shift and go to state 228
    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    else_part                      shift and go to state 227
    empty                          shift and go to state 229

state 225

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 230


state 226

    (77) stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN . SEMICOLON

    SEMICOLON       shift and go to state 231


state 227

    (41) if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .

    RBRACE          reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    ID              reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    INCREMENT       reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    DECREMENT       reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    WHILE           reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    DO              reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    BREAK           reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    CONTINUE        reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    IF              reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    RETURN          reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    FOR             reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    INT             reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    FLOAT           reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    DOUBLE          reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    STRINGTYPE      reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    BOOL            reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    CHAR            reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    VOID            reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    VAR             reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)
    LIST            reduce using rule 41 (if_stmt -> IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part .)


state 228

    (42) else_part -> ELSE . LBRACE stmt_list RBRACE

    LBRACE          shift and go to state 232


state 229

    (43) else_part -> empty .

    RBRACE          reduce using rule 43 (else_part -> empty .)
    ID              reduce using rule 43 (else_part -> empty .)
    INCREMENT       reduce using rule 43 (else_part -> empty .)
    DECREMENT       reduce using rule 43 (else_part -> empty .)
    WHILE           reduce using rule 43 (else_part -> empty .)
    DO              reduce using rule 43 (else_part -> empty .)
    BREAK           reduce using rule 43 (else_part -> empty .)
    CONTINUE        reduce using rule 43 (else_part -> empty .)
    IF              reduce using rule 43 (else_part -> empty .)
    RETURN          reduce using rule 43 (else_part -> empty .)
    FOR             reduce using rule 43 (else_part -> empty .)
    INT             reduce using rule 43 (else_part -> empty .)
    FLOAT           reduce using rule 43 (else_part -> empty .)
    DOUBLE          reduce using rule 43 (else_part -> empty .)
    STRINGTYPE      reduce using rule 43 (else_part -> empty .)
    BOOL            reduce using rule 43 (else_part -> empty .)
    CHAR            reduce using rule 43 (else_part -> empty .)
    VOID            reduce using rule 43 (else_part -> empty .)
    VAR             reduce using rule 43 (else_part -> empty .)
    LIST            reduce using rule 43 (else_part -> empty .)


state 230

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 233
    empty                          shift and go to state 139

state 231

    (77) stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .

    RBRACE          reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    ID              reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    INCREMENT       reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    DECREMENT       reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    WHILE           reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    DO              reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    BREAK           reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    CONTINUE        reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    IF              reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    RETURN          reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    FOR             reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    INT             reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    FLOAT           reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    DOUBLE          reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    STRINGTYPE      reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    BOOL            reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    CHAR            reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    VOID            reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    VAR             reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)
    LIST            reduce using rule 77 (stmt -> DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON .)


state 232

    (42) else_part -> ELSE LBRACE . stmt_list RBRACE
    (33) stmt_list -> . stmt_list stmt
    (34) stmt_list -> . empty
    (93) empty -> .

    RBRACE          reduce using rule 93 (empty -> .)
    ID              reduce using rule 93 (empty -> .)
    INCREMENT       reduce using rule 93 (empty -> .)
    DECREMENT       reduce using rule 93 (empty -> .)
    WHILE           reduce using rule 93 (empty -> .)
    DO              reduce using rule 93 (empty -> .)
    BREAK           reduce using rule 93 (empty -> .)
    CONTINUE        reduce using rule 93 (empty -> .)
    IF              reduce using rule 93 (empty -> .)
    RETURN          reduce using rule 93 (empty -> .)
    FOR             reduce using rule 93 (empty -> .)
    INT             reduce using rule 93 (empty -> .)
    FLOAT           reduce using rule 93 (empty -> .)
    DOUBLE          reduce using rule 93 (empty -> .)
    STRINGTYPE      reduce using rule 93 (empty -> .)
    BOOL            reduce using rule 93 (empty -> .)
    CHAR            reduce using rule 93 (empty -> .)
    VOID            reduce using rule 93 (empty -> .)
    VAR             reduce using rule 93 (empty -> .)
    LIST            reduce using rule 93 (empty -> .)

    stmt_list                      shift and go to state 234
    empty                          shift and go to state 139

state 233

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 235
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    assign_stmt                    shift and go to state 152
    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155
    type                           shift and go to state 147

state 234

    (42) else_part -> ELSE LBRACE stmt_list . RBRACE
    (33) stmt_list -> stmt_list . stmt
    (35) stmt -> . var_decl
    (36) stmt -> . assign_stmt
    (37) stmt -> . if_stmt
    (38) stmt -> . return_stmt
    (39) stmt -> . for_stmt
    (46) stmt -> . ID INCREMENT SEMICOLON
    (47) stmt -> . ID DECREMENT SEMICOLON
    (48) stmt -> . INCREMENT ID SEMICOLON
    (49) stmt -> . DECREMENT ID SEMICOLON
    (76) stmt -> . WHILE LPAREN expr RPAREN LBRACE stmt_list RBRACE
    (77) stmt -> . DO LBRACE stmt_list RBRACE WHILE LPAREN expr RPAREN SEMICOLON
    (78) stmt -> . BREAK SEMICOLON
    (79) stmt -> . CONTINUE SEMICOLON
    (16) var_decl -> . type ID EQUALS expr SEMICOLON
    (17) var_decl -> . type ID SEMICOLON
    (18) var_decl -> . type ID LBRACKET RBRACKET SEMICOLON
    (19) var_decl -> . type ID LBRACKET RBRACKET EQUALS expr SEMICOLON
    (40) assign_stmt -> . ID EQUALS expr SEMICOLON
    (87) assign_stmt -> . ID PLUSEQ expr SEMICOLON
    (88) assign_stmt -> . ID MINUSEQ expr SEMICOLON
    (89) assign_stmt -> . ID TIMESEQ expr SEMICOLON
    (90) assign_stmt -> . ID DIVEQ expr SEMICOLON
    (91) assign_stmt -> . ID MODEQ expr SEMICOLON
    (41) if_stmt -> . IF LPAREN expr RPAREN LBRACE stmt_list RBRACE else_part
    (44) return_stmt -> . RETURN expr SEMICOLON
    (45) for_stmt -> . FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE
    (24) type -> . INT
    (25) type -> . FLOAT
    (26) type -> . DOUBLE
    (27) type -> . STRINGTYPE
    (28) type -> . BOOL
    (29) type -> . CHAR
    (30) type -> . VOID
    (31) type -> . VAR
    (32) type -> . LIST LT type GT

    RBRACE          shift and go to state 236
    ID              shift and go to state 148
    INCREMENT       shift and go to state 156
    DECREMENT       shift and go to state 157
    WHILE           shift and go to state 158
    DO              shift and go to state 159
    BREAK           shift and go to state 160
    CONTINUE        shift and go to state 161
    IF              shift and go to state 162
    RETURN          shift and go to state 163
    FOR             shift and go to state 164
    INT             shift and go to state 29
    FLOAT           shift and go to state 30
    DOUBLE          shift and go to state 31
    STRINGTYPE      shift and go to state 32
    BOOL            shift and go to state 33
    CHAR            shift and go to state 34
    VOID            shift and go to state 35
    VAR             shift and go to state 36
    LIST            shift and go to state 37

    stmt                           shift and go to state 150
    var_decl                       shift and go to state 151
    assign_stmt                    shift and go to state 152
    if_stmt                        shift and go to state 153
    return_stmt                    shift and go to state 154
    for_stmt                       shift and go to state 155
    type                           shift and go to state 147

state 235

    (45) for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    ID              reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    DECREMENT       reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    DO              reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    IF              reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    INT             reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 45 (for_stmt -> FOR LPAREN assign_stmt expr SEMICOLON assign_stmt RPAREN LBRACE stmt_list RBRACE .)


state 236

    (42) else_part -> ELSE LBRACE stmt_list RBRACE .

    RBRACE          reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    ID              reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    INCREMENT       reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    DECREMENT       reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    WHILE           reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    DO              reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    BREAK           reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    CONTINUE        reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    IF              reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    RETURN          reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    FOR             reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    INT             reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    FLOAT           reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    DOUBLE          reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    STRINGTYPE      reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    BOOL            reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    CHAR            reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    VOID            reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    VAR             reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)
    LIST            reduce using rule 42 (else_part -> ELSE LBRACE stmt_list RBRACE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for PLUS in state 128 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 128 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 128 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 128 resolved as shift
WARNING: shift/reduce conflict for MOD in state 128 resolved as shift
WARNING: shift/reduce conflict for EQ in state 128 resolved as shift
WARNING: shift/reduce conflict for NE in state 128 resolved as shift
WARNING: shift/reduce conflict for LT in state 128 resolved as shift
WARNING: shift/reduce conflict for LE in state 128 resolved as shift
WARNING: shift/reduce conflict for GT in state 128 resolved as shift
WARNING: shift/reduce conflict for GE in state 128 resolved as shift
WARNING: shift/reduce conflict for AND in state 128 resolved as shift
WARNING: shift/reduce conflict for OR in state 128 resolved as shift
WARNING: shift/reduce conflict for DOT in state 128 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 128 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 128 resolved as shift
WARNING: shift/reduce conflict for AMPERSAND in state 128 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 128 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 129 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 129 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 129 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 129 resolved as shift
WARNING: shift/reduce conflict for MOD in state 129 resolved as shift
WARNING: shift/reduce conflict for EQ in state 129 resolved as shift
WARNING: shift/reduce conflict for NE in state 129 resolved as shift
WARNING: shift/reduce conflict for LT in state 129 resolved as shift
WARNING: shift/reduce conflict for LE in state 129 resolved as shift
WARNING: shift/reduce conflict for GT in state 129 resolved as shift
WARNING: shift/reduce conflict for GE in state 129 resolved as shift
WARNING: shift/reduce conflict for AND in state 129 resolved as shift
WARNING: shift/reduce conflict for OR in state 129 resolved as shift
WARNING: shift/reduce conflict for DOT in state 129 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 129 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 129 resolved as shift
WARNING: shift/reduce conflict for AMPERSAND in state 129 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 129 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 134 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 134 resolved as shift
WARNING: shift/reduce conflict for MOD in state 134 resolved as shift
WARNING: shift/reduce conflict for EQ in state 134 resolved as shift
WARNING: shift/reduce conflict for NE in state 134 resolved as shift
WARNING: shift/reduce conflict for LT in state 134 resolved as shift
WARNING: shift/reduce conflict for LE in state 134 resolved as shift
WARNING: shift/reduce conflict for GT in state 134 resolved as shift
WARNING: shift/reduce conflict for GE in state 134 resolved as shift
WARNING: shift/reduce conflict for AND in state 134 resolved as shift
WARNING: shift/reduce conflict for OR in state 134 resolved as shift
WARNING: shift/reduce conflict for DOT in state 134 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 134 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 134 resolved as shift
WARNING: shift/reduce conflict for AMPERSAND in state 134 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for MOD in state 142 resolved as shift
WARNING: shift/reduce conflict for EQ in state 142 resolved as shift
WARNING: shift/reduce conflict for NE in state 142 resolved as shift
WARNING: shift/reduce conflict for LT in state 142 resolved as shift
WARNING: shift/reduce conflict for LE in state 142 resolved as shift
WARNING: shift/reduce conflict for GT in state 142 resolved as shift
WARNING: shift/reduce conflict for GE in state 142 resolved as shift
WARNING: shift/reduce conflict for AND in state 142 resolved as shift
WARNING: shift/reduce conflict for OR in state 142 resolved as shift
WARNING: shift/reduce conflict for DOT in state 142 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 142 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 142 resolved as shift
WARNING: shift/reduce conflict for AMPERSAND in state 142 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 165 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for MOD in state 165 resolved as shift
WARNING: shift/reduce conflict for EQ in state 165 resolved as shift
WARNING: shift/reduce conflict for NE in state 165 resolved as shift
WARNING: shift/reduce conflict for LT in state 165 resolved as shift
WARNING: shift/reduce conflict for LE in state 165 resolved as shift
WARNING: shift/reduce conflict for GT in state 165 resolved as shift
WARNING: shift/reduce conflict for GE in state 165 resolved as shift
WARNING: shift/reduce conflict for AND in state 165 resolved as shift
WARNING: shift/reduce conflict for OR in state 165 resolved as shift
WARNING: shift/reduce conflict for DOT in state 165 resolved as shift
WARNING: shift/reduce conflict for LBRACKET in state 165 resolved as shift
WARNING: shift/reduce conflict for PIPE in state 165 resolved as shift
WARNING: shift/reduce conflict for AMPERSAND in state 165 resolved as shift
WARNING: shift/reduce conflict for QUESTION in state 165 resolved as shift
WARNING: reduce/reduce conflict in state 99 resolved using rule (type -> INT)
WARNING: rejected rule (expr -> INT) in state 99
WARNING: reduce/reduce conflict in state 100 resolved using rule (type -> FLOAT)
WARNING: rejected rule (expr -> FLOAT) in state 100
WARNING: reduce/reduce conflict in state 101 resolved using rule (type -> DOUBLE)
WARNING: rejected rule (expr -> DOUBLE) in state 101
WARNING: reduce/reduce conflict in state 102 resolved using rule (type -> CHAR)
WARNING: rejected rule (expr -> CHAR) in state 102
